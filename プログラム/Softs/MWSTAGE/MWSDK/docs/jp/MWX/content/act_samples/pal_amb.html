<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mono Wireless Inc." />
  <title>PAL_AMB</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">PAL_AMB</h1>
<p class="author">Mono Wireless Inc.</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#pal_amb">PAL_AMB</a><ul>
<li><a href="#アクトの機能">アクトの機能</a></li>
<li><a href="#アクトの使い方">アクトの使い方</a><ul>
<li><a href="#必要なtwelite">必要なTWELITE</a></li>
</ul></li>
<li><a href="#アクトの解説">アクトの解説</a><ul>
<li><a href="#インクルード">インクルード</a></li>
<li><a href="#setup">setup()</a></li>
<li><a href="#loop">loop()</a></li>
<li><a href="#on_tx_comp">on_tx_comp()</a></li>
<li><a href="#sleepnow">sleepNow()</a></li>
<li><a href="#wakeup">wakeup()</a></li>
</ul></li>
<li><a href="#応用編">応用編</a><ul>
<li><a href="#消費エネルギーの削減">消費エネルギーの削減</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="pal_amb">PAL_AMB</h1>
<p><a target=_blank href="https://mono-wireless.com/jp/products/twelite-pal/sense/amb-pal.html">環境センサーパル AMBIENT SENSE PAL</a> を用い、センサー値の取得を行います。</p>
<div class="success">
<p>このアクトには以下が含まれます。</p>
<ul>
<li>無線パケットの送受信</li>
<li>インタラクティブモードによる設定 - <a href="../settings/stg_std.html">&lt;STG_STD&gt;</a></li>
<li>ステートマシンによる状態遷移制御 - <a href="../api-reference/classes/smsimple-suttomashin.html">&lt;SM_SIMPLE&gt;</a></li>
<li><a href="../boards/pal/pal_amb.html">&lt;PAL_AMB&gt;</a>ボードビヘイビアによるボード操作</li>
</ul>
</div>
<h2 id="アクトの機能">アクトの機能</h2>
<ul>
<li>環境センサーパル AMPIENT SENSE PAL を用い、センサー値の取得を行います。</li>
<li>コイン電池で動作させるための、スリープ機能を利用します。</li>
</ul>
<h2 id="アクトの使い方">アクトの使い方</h2>
<h3 id="必要なtwelite">必要なTWELITE</h3>
<table>
<thead>
<tr class="header">
<th>役割</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>親機</td>
<td><a target=_blank href="https://mono-wireless.com/jp/products/MoNoStick/">MONOSTICK BLUEまたはRED</a>アクト<a href="parent_monostick.html">Parent_MONOSTICK</a>を動作させる。</td>
</tr>
<tr class="even">
<td>子機</td>
<td><a target=_blank href="https://mono-wireless.com/jp/products/twelite-pal/BnR/index.html">BLUE PAL または RED PAL</a> +<a target=_blank href="https://mono-wireless.com/jp/products/twelite-pal/sense/amb-pal.html">環境センサーパル AMBIENT SENSE PAL</a></td>
</tr>
</tbody>
</table>
<h2 id="アクトの解説">アクトの解説</h2>
<h3 id="インクルード">インクルード</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;NWK_SIMPLE&gt;</span><span class="co">// ネットワークサポート</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;PAL_AMB&gt;</span><span class="pp">   </span><span class="co">// PAL_AMB</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="pp">#include </span><span class="im">&lt;STG_STD&gt;</span><span class="pp">   </span><span class="co">// インタラクティブモード</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&lt;SM_SIMPLE&gt;</span><span class="pp"> </span><span class="co">// 簡易ステートマシン</span></a></code></pre></div>
<p>環境センサーパル <a href="../boards/pal/pal_amb.html"><code>&lt;PAL_AMB&gt;</code></a> のボードビヘイビアをインクルードします。</p>
<h3 id="setup">setup()</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="co">/*** SETUP section */</span></a>
<a class="sourceLine" id="cb2-3" title="3">    step.setup(); <span class="co">// ステートマシンの初期化</span></a>
<a class="sourceLine" id="cb2-4" title="4">        </a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="co">// PAL_AMBのボードビヘイビアを読み込む</span></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="kw">auto</span>&amp;&amp; brd = the_twelite.board.use&lt;PAL_AMB&gt;();</a>
<a class="sourceLine" id="cb2-7" title="7">    </a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="co">// インタラクティブモードを読み込む</span></a>
<a class="sourceLine" id="cb2-9" title="9">    <span class="kw">auto</span>&amp;&amp; set = the_twelite.settings.use&lt;STG_STD&gt;();</a>
<a class="sourceLine" id="cb2-10" title="10">    set &lt;&lt; SETTINGS::appname(FOURCHARS);</a>
<a class="sourceLine" id="cb2-11" title="11">    set &lt;&lt; SETTINGS::appid_default(APP_ID); <span class="co">// set default appID</span></a>
<a class="sourceLine" id="cb2-12" title="12">    set.hide_items(E_STGSTD_SETID::POWER_N_RETRY, E_STGSTD_SETID::OPT_DWORD2, E_STGSTD_SETID::OPT_DWORD3, E_STGSTD_SETID::OPT_DWORD4, E_STGSTD_SETID::ENC_KEY_STRING, E_STGSTD_SETID::ENC_MODE);</a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14">    <span class="co">// SET ピンを検出した場合は、インタラクティブモードを起動する</span></a>
<a class="sourceLine" id="cb2-15" title="15">    <span class="cf">if</span> (digitalRead(brd.PIN_BTN) == PIN_STATE::LOW) {</a>
<a class="sourceLine" id="cb2-16" title="16">        set &lt;&lt; SETTINGS::open_at_start();</a>
<a class="sourceLine" id="cb2-17" title="17">        step.next(STATE::INTERACTIVE);</a>
<a class="sourceLine" id="cb2-18" title="18">        <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb2-19" title="19">    }</a>
<a class="sourceLine" id="cb2-20" title="20"></a>
<a class="sourceLine" id="cb2-21" title="21">    <span class="co">// インタラクティブモードのデータを読み出す</span></a>
<a class="sourceLine" id="cb2-22" title="22">    set.reload();</a>
<a class="sourceLine" id="cb2-23" title="23">    APP_ID = set.u32appid();</a>
<a class="sourceLine" id="cb2-24" title="24">    CHANNEL = set.u8ch();</a>
<a class="sourceLine" id="cb2-25" title="25">    OPT_BITS = set.u32opt1();</a>
<a class="sourceLine" id="cb2-26" title="26"></a>
<a class="sourceLine" id="cb2-27" title="27">    <span class="co">// DIPスイッチとインタラクティブモードの設定からLIDを決める</span></a>
<a class="sourceLine" id="cb2-28" title="28">    LID = (brd.get_DIPSW_BM() &amp; <span class="bn">0x07</span>); <span class="co">// 1st priority is DIP SW</span></a>
<a class="sourceLine" id="cb2-29" title="29">    <span class="cf">if</span> (LID == <span class="dv">0</span>) LID = set.u8devid(); <span class="co">// 2nd is setting.</span></a>
<a class="sourceLine" id="cb2-30" title="30">    <span class="cf">if</span> (LID == <span class="dv">0</span>) LID = <span class="bn">0xFE</span>; <span class="co">// if still 0, set 0xFE (anonymous child)</span></a>
<a class="sourceLine" id="cb2-31" title="31">    </a>
<a class="sourceLine" id="cb2-32" title="32">    <span class="co">// LED初期化</span></a>
<a class="sourceLine" id="cb2-33" title="33">    brd.set_led(LED_TIMER::BLINK, <span class="dv">10</span>); <span class="co">// blink (on 10ms/ off 10ms)</span></a>
<a class="sourceLine" id="cb2-34" title="34"></a>
<a class="sourceLine" id="cb2-35" title="35">    <span class="co">// the twelite main object.</span></a>
<a class="sourceLine" id="cb2-36" title="36">    the_twelite</a>
<a class="sourceLine" id="cb2-37" title="37">        &lt;&lt; TWENET::appid(APP_ID)     <span class="co">// set application ID (identify network group)</span></a>
<a class="sourceLine" id="cb2-38" title="38">        &lt;&lt; TWENET::channel(CHANNEL); <span class="co">// set channel (pysical channel)</span></a>
<a class="sourceLine" id="cb2-39" title="39"></a>
<a class="sourceLine" id="cb2-40" title="40">    <span class="co">// Register Network</span></a>
<a class="sourceLine" id="cb2-41" title="41">    <span class="kw">auto</span>&amp;&amp; nwk = the_twelite.network.use&lt;NWK_SIMPLE&gt;();</a>
<a class="sourceLine" id="cb2-42" title="42">    nwk &lt;&lt; NWK_SIMPLE::logical_id(u8ID); <span class="co">// set Logical ID. (0xFE means a child device with no ID)</span></a>
<a class="sourceLine" id="cb2-43" title="43"></a>
<a class="sourceLine" id="cb2-44" title="44">    <span class="co">/*** </span><span class="re">BEGIN</span><span class="co"> section */</span></a>
<a class="sourceLine" id="cb2-45" title="45">    Wire.begin(); <span class="co">// start two wire serial bus.</span></a>
<a class="sourceLine" id="cb2-46" title="46">    Analogue.begin(pack_bits(PIN_ANALOGUE::A1, PIN_ANALOGUE::VCC)); <span class="co">// _start continuous adc capture.</span></a>
<a class="sourceLine" id="cb2-47" title="47"></a>
<a class="sourceLine" id="cb2-48" title="48">    the_twelite.begin(); <span class="co">// start twelite!</span></a>
<a class="sourceLine" id="cb2-49" title="49"></a>
<a class="sourceLine" id="cb2-50" title="50">    startSensorCapture(); <span class="co">// start sensor capture!</span></a>
<a class="sourceLine" id="cb2-51" title="51"></a>
<a class="sourceLine" id="cb2-52" title="52">    <span class="co">/*** INIT message */</span></a>
<a class="sourceLine" id="cb2-53" title="53">    Serial &lt;&lt; <span class="st">&quot;--- PAL_AMB:&quot;</span> &lt;&lt; FOURCHARS &lt;&lt; <span class="st">&quot; ---&quot;</span> &lt;&lt; mwx::crlf;</a>
<a class="sourceLine" id="cb2-54" title="54">}</a></code></pre></div>
<p>最初に変数などの初期化を行います。ここではステートマシンstepの初期化を行っています。</p>
<p>最初にボードサポート <a href="parent_monostick.html"><code>&lt;PAL_AMB&gt;</code></a> を登録します。ボードサポートの初期化時にセンサーやDIOの初期化が行われます。最初に行うのは、ボードのDIP SWなどの状態を確認してから、ネットワークの設定などを行うといった処理が一般的だからです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">auto</span>&amp;&amp; brd = the_twelite.board.use&lt;PAL_AMB&gt;();</a></code></pre></div>
<p>つづいて、インタラクティブモード関連の初期化と読出しを行います。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// インタラクティブモードを読み込む</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">auto</span>&amp;&amp; set = the_twelite.settings.use&lt;STG_STD&gt;();</a>
<a class="sourceLine" id="cb4-3" title="3">set &lt;&lt; SETTINGS::appname(FOURCHARS);</a>
<a class="sourceLine" id="cb4-4" title="4">set &lt;&lt; SETTINGS::appid_default(APP_ID); <span class="co">// set default appID</span></a>
<a class="sourceLine" id="cb4-5" title="5">set.hide_items(E_STGSTD_SETID::POWER_N_RETRY, E_STGSTD_SETID::OPT_DWORD2, E_STGSTD_SETID::OPT_DWORD3, E_STGSTD_SETID::OPT_DWORD4, E_STGSTD_SETID::ENC_KEY_STRING, E_STGSTD_SETID::ENC_MODE);</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">// SET ピンを検出した場合は、インタラクティブモードを起動する</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="cf">if</span> (digitalRead(brd.PIN_BTN) == PIN_STATE::LOW) {</a>
<a class="sourceLine" id="cb4-9" title="9">    set &lt;&lt; SETTINGS::open_at_start();</a>
<a class="sourceLine" id="cb4-10" title="10">    step.next(STATE::INTERACTIVE);</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb4-12" title="12">}</a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">// インタラクティブモードのデータを読み出す</span></a>
<a class="sourceLine" id="cb4-15" title="15">set.reload();</a>
<a class="sourceLine" id="cb4-16" title="16">APP_ID = set.u32appid();</a>
<a class="sourceLine" id="cb4-17" title="17">CHANNEL = set.u8ch();</a>
<a class="sourceLine" id="cb4-18" title="18">OPT_BITS = set.u32opt1();</a>
<a class="sourceLine" id="cb4-19" title="19"></a>
<a class="sourceLine" id="cb4-20" title="20"><span class="co">// DIPスイッチとインタラクティブモードの設定からLIDを決める</span></a>
<a class="sourceLine" id="cb4-21" title="21">LID = (brd.get_DIPSW_BM() &amp; <span class="bn">0x07</span>); <span class="co">// 1st priority is DIP SW</span></a>
<a class="sourceLine" id="cb4-22" title="22"><span class="cf">if</span> (LID == <span class="dv">0</span>) LID = set.u8devid(); <span class="co">// 2nd is setting.</span></a>
<a class="sourceLine" id="cb4-23" title="23"><span class="cf">if</span> (LID == <span class="dv">0</span>) LID = <span class="bn">0xFE</span>; <span class="co">// if still 0, set 0xFE (anonymous child)</span></a></code></pre></div>
<p>ここではsetオブジェクトの取得、アプリ名の反映、デフォルトのアプリケーションIDの反映、設定メニューで不要項目の削除を行います。</p>
<p>次にSETピンの状態を読み出します。このサンプルはスリープによる間欠動作を行うため、+++入力によるインタラクティブモード遷移は出来ません。替わりに起動時のSETピン=LO状態でインタラクティブモードに遷移します。このとき<code>SETTINGS::open_at_start()</code>を指定していますが、これは<code>setup()</code>を終了後速やかにインタラクティブモード画面に遷移する指定です。</p>
<p>最後に<code>.reload()</code>を実行して設定値をEEPROMから読み出します。設定値を各変数にコピーしています。</p>
<p>続いてLEDの設定を行います。ここでは 10ms おきに ON/OFF の点滅の設定をします（スリープを行い起床時間が短いアプリケーションでは、起床中は点灯するという設定とほぼ同じ意味合いになります）。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1">    brd.set_led(LED_TIMER::BLINK, <span class="dv">10</span>); <span class="co">// blink (on 10ms/ off 10ms)</span></a></code></pre></div>
<p>このアクトではもっぱら無線パケットを送信しますので、TWENET の設定では動作中に受信回路をオープンにする指定（<code>TWENET::rx_when_idle()</code>）は含めません。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">    the_twelite</a>
<a class="sourceLine" id="cb6-2" title="2">        &lt;&lt; TWENET::appid(APP_ID)     <span class="co">// set application ID (identify network group)</span></a>
<a class="sourceLine" id="cb6-3" title="3">        &lt;&lt; TWENET::channel(CHANNEL); <span class="co">// set channel (pysical channel)</span></a></code></pre></div>
<p>ボード上のセンサーはI2Cバスを用いますので、バスを利用開始しておきます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1">Wire.begin(); <span class="co">// start two wire serial bus.</span></a></code></pre></div>
<p>ボード上のセンサーの取得を開始します。<a href="pal_amb.html#%22startsensorcapture"><code>startSensorCapture()</code></a>の解説を参照ください。</p>
<pre><code>startSensorCapture();</code></pre>
<h3 id="loop">loop()</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> loop() {</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">auto</span>&amp;&amp; brd = the_twelite.board.use&lt;PAL_AMB&gt;();</a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="cf">do</span> {</a>
<a class="sourceLine" id="cb9-5" title="5">        <span class="cf">switch</span> (step.state()) {</a>
<a class="sourceLine" id="cb9-6" title="6">         <span class="co">// 各状態の振る舞い</span></a>
<a class="sourceLine" id="cb9-7" title="7">        <span class="cf">case</span> STATE::INIT:</a>
<a class="sourceLine" id="cb9-8" title="8">        ...</a>
<a class="sourceLine" id="cb9-9" title="9">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb9-10" title="10">        ...</a>
<a class="sourceLine" id="cb9-11" title="11">        }</a>
<a class="sourceLine" id="cb9-12" title="12">    <span class="cf">while</span>(step.b_more_loop());</a>
<a class="sourceLine" id="cb9-13" title="13">}   </a></code></pre></div>
<p><code>loop()</code>は、<a href="../api-reference/classes/smsimple-suttomashin.html">SM_SIMPLEステートマシン</a><code>step</code>を用いた制御を行っています。スリープ復帰からセンサー値取得、無線パケット送信、送信完了待ち、スリープといった一連の流れを簡潔に表現するためです。ループの戦闘では<code>brd</code>オブジェクトを取得しています。</p>
<h4 id="case-stateinteractive">case STATE::INTERACTIVE:</h4>
<p>インタラクティブモード中にメインループが動作するのは都合が悪いため、この状態に固定します。</p>
<h4 id="case-stateinit">case STATE::INIT:</h4>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1">brd.sns_SHTC3.begin();</a>
<a class="sourceLine" id="cb10-2" title="2">brd.sns_LTR308ALS.begin();</a>
<a class="sourceLine" id="cb10-3" title="3"></a>
<a class="sourceLine" id="cb10-4" title="4">step.next(STATE::SENSOR);</a></code></pre></div>
<p>センサーのデータ取得を開始します。</p>
<h4 id="case-statesensor">case STATE::SENSOR:</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1">    <span class="cf">if</span> (!brd.sns_LTR308ALS.available()) {</a>
<a class="sourceLine" id="cb11-2" title="2">        brd.sns_LTR308ALS.process_ev(E_EVENT_TICK_TIMER);</a>
<a class="sourceLine" id="cb11-3" title="3">    }</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="cf">if</span> (!brd.sns_SHTC3.available()) {</a>
<a class="sourceLine" id="cb11-6" title="6">        brd.sns_SHTC3.process_ev(E_EVENT_TICK_TIMER);</a>
<a class="sourceLine" id="cb11-7" title="7">    }</a></code></pre></div>
<p>ボード上のセンサーは <code>.sns_LTR308ALS</code> または <code>.sns_SHTC3</code> という名前でアクセスでき、このオブジェクトに操作を行います。センサーの完了待ちを行います。まだセンサーの取得が終わっていない場合(<code>.available()</code>が<code>false</code>)はセンサーに対して時間経過のイベント(<code>.process_ev(E_EVENT_TICK_TIMER)</code>)を送付します。</p>
<p>上記２つのセンサーがavailableになった時点で、センサー値を取得し、STATE_TXに遷移します。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="co">// now sensor data is ready.</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="cf">if</span> (brd.sns_LTR308ALS.available() &amp;&amp; brd.sns_SHTC3.available()) {</a>
<a class="sourceLine" id="cb12-3" title="3">    sensor.u32luminance = brd.sns_LTR308ALS.get_luminance();</a>
<a class="sourceLine" id="cb12-4" title="4">    sensor.i16temp = brd.sns_SHTC3.get_temp_cent();</a>
<a class="sourceLine" id="cb12-5" title="5">    sensor.i16humid = brd.sns_SHTC3.get_humid_per_dmil();</a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7">    Serial &lt;&lt; <span class="st">&quot;..finish sensor capture.&quot;</span> &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb12-8" title="8">        &lt;&lt; <span class="st">&quot;  LTR308ALS: lumi=&quot;</span> &lt;&lt; <span class="dt">int</span>(sensor.u32luminance) &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb12-9" title="9">        &lt;&lt; <span class="st">&quot;  SHTC3    : temp=&quot;</span> &lt;&lt; div100(sensor.i16temp) &lt;&lt; <span class="ch">&#39;C&#39;</span> &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb12-10" title="10">        &lt;&lt; <span class="st">&quot;             humd=&quot;</span> &lt;&lt; div100(sensor.i16humid) &lt;&lt; <span class="ch">&#39;%&#39;</span> &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb12-11" title="11">        ;</a>
<a class="sourceLine" id="cb12-12" title="12">    Serial.flush();</a>
<a class="sourceLine" id="cb12-13" title="13"></a>
<a class="sourceLine" id="cb12-14" title="14">    step.next(STATE::TX);</a>
<a class="sourceLine" id="cb12-15" title="15">}</a></code></pre></div>
<p>照度センサーは<code>.get_luminance() : uint32_t</code>で得られます。</p>
<p>温湿度センサーは以下のように取得できます。</p>
<ul>
<li><code>.get_temp_cent()</code> : <code>int16_t</code> : 1℃を100とした温度 (25.6 ℃なら 2560)</li>
<li><code>.get_temp()</code> : <code>float</code> : float値 (25.6 ℃なら 25.6)</li>
<li><code>.get_humid_dmil()</code> : <code>int16_t</code> : 1%を100とした湿度 (56.8%なら 5680)</li>
<li><code>.get_temp()</code> : <code>float</code> : float値 (56.8%なら 56.8)</li>
</ul>
<h4 id="case-statetx">case STATE::TX:</h4>
<p>送信手続きについては他のアクトのサンプルと同様です。ここでは、再送１回、再送遅延を最小にする設定になっています。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1">    pkt &lt;&lt; tx_addr(<span class="bn">0x00</span>)  <span class="co">// 親機0x00宛</span></a>
<a class="sourceLine" id="cb13-2" title="2">        &lt;&lt; tx_retry(<span class="bn">0x1</span>)    <span class="co">// リトライ1回</span></a>
<a class="sourceLine" id="cb13-3" title="3">        &lt;&lt; tx_packet_delay(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>); <span class="co">// 遅延は最小限</span></a></code></pre></div>
<p>パケットのペイロード部に識別子の<code>FOURCHARS</code>とセンサーデータを格納します。得られた値のうち温度値は <code>int16_t</code>ですが、送信パケットのデータ構造は符号なしで格納するため、<code>uint16_t</code>にキャストしています。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1">pack_bytes(pkt.get_payload() </a>
<a class="sourceLine" id="cb14-2" title="2">    , make_pair(FOURCHARS, <span class="dv">4</span>)  </a>
<a class="sourceLine" id="cb14-3" title="3">    , <span class="dt">uint32_t</span>(sensor.u32luminance)</a>
<a class="sourceLine" id="cb14-4" title="4">    , <span class="dt">uint16_t</span>(sensor.i16temp)</a>
<a class="sourceLine" id="cb14-5" title="5">    , <span class="dt">uint16_t</span>(sensor.i16humid)</a>
<a class="sourceLine" id="cb14-6" title="6">);</a></code></pre></div>
<p>送信要求を行います。送信要求が成功したら送信完了街の準備を行います。完了イベントを待つために<code>.clear_flag()</code>、万が一のときのタイムアウトを<code>set_timeout(100)</code>を指定します。パラメータの100の単位はミリ秒[ms]です。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// do transmit</span></a>
<a class="sourceLine" id="cb15-2" title="2">MWX_APIRET ret = pkt.transmit();</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="cf">if</span> (ret) {</a>
<a class="sourceLine" id="cb15-5" title="5">    step.clear_flag(); <span class="co">// waiting for flag is set.</span></a>
<a class="sourceLine" id="cb15-6" title="6">    step.set_timeout(<span class="dv">100</span>); <span class="co">// set timeout</span></a>
<a class="sourceLine" id="cb15-7" title="7">    step.next(STATE::TX_WAIT_COMP);</a>
<a class="sourceLine" id="cb15-8" title="8">}</a></code></pre></div>
<h4 id="case-statetx_wait_comp">case STATE::TX_WAIT_COMP:</h4>
<p>ここではタイムアウトの判定、送信完了イベントの判定を行います。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="cf">if</span> (step.is_timeout()) { <span class="co">// maybe fatal error.</span></a>
<a class="sourceLine" id="cb16-2" title="2">    the_twelite.reset_system();</a>
<a class="sourceLine" id="cb16-3" title="3">}</a>
<a class="sourceLine" id="cb16-4" title="4"><span class="cf">if</span> (step.is_flag_ready()) { <span class="co">// when tx is performed</span></a>
<a class="sourceLine" id="cb16-5" title="5">    Serial &lt;&lt; <span class="st">&quot;..transmit complete.&quot;</span> &lt;&lt; mwx::crlf;</a>
<a class="sourceLine" id="cb16-6" title="6">    Serial.flush();</a>
<a class="sourceLine" id="cb16-7" title="7">    step.next(STATE::GO_SLEEP);</a>
<a class="sourceLine" id="cb16-8" title="8">}</a></code></pre></div>
<h4 id="statego_sleep">STATE::GO_SLEEP:</h4>
<p><code>sleepNow()</code>の処理を行います。</p>
<h3 id="on_tx_comp">on_tx_comp()</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">void</span> on_tx_comp(mwx::packet_ev_tx&amp; ev, <span class="dt">bool_t</span> &amp;b_handled) {</a>
<a class="sourceLine" id="cb17-2" title="2">    step.set_flag(ev.bStatus);</a>
<a class="sourceLine" id="cb17-3" title="3">}</a></code></pre></div>
<p>送信完了時に呼び出されるシステムイベントです。ここでは<code>.set_flag()</code>により完了としています。</p>
<h3 id="sleepnow">sleepNow()</h3>
<p>スリープに入る手続きをまとめています。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="dt">void</span> sleepNow() {</a>
<a class="sourceLine" id="cb18-2" title="2">    step.on_sleep(<span class="kw">false</span>); <span class="co">// reset state machine.</span></a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="co">// randomize sleep duration.</span></a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="dt">uint32_t</span> u32ct = <span class="dv">1750</span> + random(<span class="dv">0</span>,<span class="dv">500</span>);</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7">    <span class="co">// output message</span></a>
<a class="sourceLine" id="cb18-8" title="8">    Serial &lt;&lt; <span class="st">&quot;..sleeping &quot;</span> &lt;&lt; <span class="dt">int</span>(u32ct) &lt;&lt; <span class="st">&quot;ms.&quot;</span> &lt;&lt; mwx::crlf;</a>
<a class="sourceLine" id="cb18-9" title="9">    Serial.flush(); <span class="co">// wait until all message printed.</span></a>
<a class="sourceLine" id="cb18-10" title="10">    </a>
<a class="sourceLine" id="cb18-11" title="11">    <span class="co">// do sleep.</span></a>
<a class="sourceLine" id="cb18-12" title="12">    the_twelite.sleep(u32ct);</a>
<a class="sourceLine" id="cb18-13" title="13">}</a></code></pre></div>
<p>スリープ前に<code>.on_sleep(false)</code>によりステートマシンの状態を初期化します。パラメータのfalseはスリープ復帰後<code>STATE::INIT(=0)</code>から始めます。</p>
<p>ここでは、起床までの時間を乱数により 1750ms から 2250ms の間に設定しています。これにより他の同じような周期で送信するデバイスのパケットとの連続的な衝突を避けます。</p>
<div class="info">
<p>周期が完全に一致すると、互いのパケットで衝突が起き通信が困難になります。通常は時間の経過とともにタイマー周期が互いにずれるため、しばらくすると通信が回復し、また時間がたつと衝突が起きるという繰り返しになります。</p>
</div>
<p>8,9行目、この例ではシリアルポートからの出力を待ってスリープに入ります。通常は消費エネルギーを最小化したいため、スリープ前のシリアルポートの出力は最小限（または無し）にします。</p>
<p>12行目、スリープに入るには <code>the_twelite.sleep()</code> を呼びます。この呼び出しの中で、ボード上のハードウェアのスリープ前の手続きなどが行われます。たとえばLEDは消灯します。</p>
<p>パラメータとしてスリープ時間をmsで指定しています。</p>
<div class="danger">
<p>TWELITE PAL では、必ず60秒以内に一度起床し、ウォッチドッグタイマーをリセットしなければなりません。スリープ時間は<code>60000</code>を超えないように指定してください。</p>
</div>
<h3 id="wakeup">wakeup()</h3>
<p>スリープから復帰し起床すると <code>wakeup()</code> が呼び出されます。そのあと<code>loop()</code> が都度呼び出されます。<code>wakeup()</code>の前に、UARTなどの各ペリフェラルやボード上のデバイスのウェイクアップ処理が行われます。例えばLEDの点灯制御を再始動します。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">void</span> wakeup() {</a>
<a class="sourceLine" id="cb19-2" title="2">    Serial  &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb19-3" title="3">            &lt;&lt; <span class="st">&quot;--- PAL_AMB:&quot;</span> &lt;&lt; FOURCHARS &lt;&lt; <span class="st">&quot; wake up ---&quot;</span></a>
<a class="sourceLine" id="cb19-4" title="4">            &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb19-5" title="5">            &lt;&lt; <span class="st">&quot;..start sensor capture again.&quot;</span></a>
<a class="sourceLine" id="cb19-6" title="6">            &lt;&lt; mwx::crlf;</a></code></pre></div>
<h2 id="応用編">応用編</h2>
<h3 id="消費エネルギーの削減">消費エネルギーの削減</h3>
<p>アクト <a href="pal_amb-usenap.html">PAL_AMB-UseNap</a>は、センサーのデータ取得待ちをスリープで行い、より低消費エネルギーで動作できます。</p>
</body>
</html>
