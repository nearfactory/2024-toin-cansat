<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mono Wireless Inc." />
  <title>PingPong</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">PingPong</h1>
<p class="author">Mono Wireless Inc.</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#pingpong">PingPong</a><ul>
<li><a href="#アクトの使い方">アクトの使い方</a><ul>
<li><a href="#必要なtwelite">必要なTWELITE</a></li>
</ul></li>
<li><a href="#アクトの解説">アクトの解説</a><ul>
<li><a href="#インクルード">インクルード</a></li>
<li><a href="#宣言部">宣言部</a></li>
<li><a href="#セットアップ-setup">セットアップ setup()</a></li>
<li><a href="#ループ-loop">ループ loop()</a></li>
<li><a href="#transmit">transmit()</a></li>
<li><a href="#on_rx_packet">on_rx_packet()</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="pingpong">PingPong</h1>
<p>2台のシリアル接続しているTWELITEの片方からPING(ピン)の無線パケットを送信すると、他方からPONG(ポン)の無線パケットが返ってきます。</p>
<div class="success">
<p>このアクトには以下が含まれます。</p>
<ul>
<li>無線パケットの受信からの速やかな応答送信</li>
<li>相手のアドレスを直接指定した送信</li>
<li>シリアルポートからの入力 - <a href="../api-reference/classes/twe-stream/#read">Serial</a></li>
<li>ディジタル（ボタン）入力 - <a href="../api-reference/predefined_objs/buttons.html">Buttons</a></li>
<li>アナログ入力 - <a href="../api-reference/predefined_objs/analogue.html">Analogue</a></li>
</ul>
</div>
<h2 id="アクトの使い方">アクトの使い方</h2>
<h3 id="必要なtwelite">必要なTWELITE</h3>
<p>いずれかを２台。</p>
<ul>
<li><a target=_blank href="https://mono-wireless.com/jp/products/MoNoStick/index.html">MONOSTICK BLUE または RED</a></li>
<li><a target=_blank href="https://mono-wireless.com/jp/products/TWE-LITE-R/index.html">TWELITE R</a> でUART接続されている<a target=_blank href="https://mono-wireless.com/jp/products/TWE-Lite-DIP/index.html">TWELITE DIP</a>など</li>
</ul>
<h2 id="アクトの解説">アクトの解説</h2>
<h3 id="インクルード">インクルード</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// use twelite mwx c++ template library</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;NWK_SIMPLE&gt;</span></a></code></pre></div>
<p>全てのアクトで<code>&lt;TWELITE&gt;</code>をインクルードします。ここでは、シンプルネットワーク <a href="../networks/nwk_simple.html"><code>&lt;NWK_SIMPLE&gt;</code></a> をインクルードしておきます。</p>
<h3 id="宣言部">宣言部</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// application ID</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="at">const</span> <span class="dt">uint32_t</span> APP_ID = <span class="bn">0x1234abcd</span>;</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">// channel</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="at">const</span> <span class="dt">uint8_t</span> CHANNEL = <span class="dv">13</span>;</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">// DIO pins</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="at">const</span> <span class="dt">uint8_t</span> PIN_BTN = <span class="dv">12</span>;</a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">/*** function prototype */</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="dt">void</span> vTransmit(<span class="at">const</span> <span class="dt">char</span>* msg, <span class="dt">uint32_t</span> addr);</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co">/*** application defs */</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">// packet message</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="at">const</span> <span class="dt">int</span> MSG_LEN = <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb2-16" title="16"><span class="at">const</span> <span class="dt">char</span> MSG_PING[] = <span class="st">&quot;PING&quot;</span>;</a>
<a class="sourceLine" id="cb2-17" title="17"><span class="at">const</span> <span class="dt">char</span> MSG_PONG[] = <span class="st">&quot;PONG&quot;</span>;</a></code></pre></div>
<ul>
<li>サンプルアクト共通宣言</li>
<li>長めの処理を関数化しているため、そのプロトタイプ宣言（送信と受信）</li>
<li>アプリケーション中のデータ保持するための変数</li>
</ul>
<h3 id="セットアップ-setup">セットアップ setup()</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co">/*** SETUP section */</span></a>
<a class="sourceLine" id="cb3-3" title="3">    Buttons.setup(<span class="dv">5</span>); <span class="co">// init button manager with 5 history table.</span></a>
<a class="sourceLine" id="cb3-4" title="4">    Analogue.setup(<span class="kw">true</span>, <span class="dv">50</span>); <span class="co">// setup analogue read (check every 50ms)</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="co">// the twelite main class</span></a>
<a class="sourceLine" id="cb3-7" title="7">    the_twelite</a>
<a class="sourceLine" id="cb3-8" title="8">        &lt;&lt; TWENET::appid(APP_ID)    <span class="co">// set application ID (identify network group)</span></a>
<a class="sourceLine" id="cb3-9" title="9">        &lt;&lt; TWENET::channel(CHANNEL) <span class="co">// set channel (pysical channel)</span></a>
<a class="sourceLine" id="cb3-10" title="10">        &lt;&lt; TWENET::rx_when_idle();  <span class="co">// open receive circuit (if not set, it can&#39;t listen packts from others)</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="co">// Register Network</span></a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="kw">auto</span>&amp;&amp; nwksmpl = the_twelite.network.use&lt;NWK_SIMPLE&gt;();</a>
<a class="sourceLine" id="cb3-14" title="14">    nwksmpl &lt;&lt; NWK_SIMPLE::logical_id(<span class="bn">0xFE</span>) <span class="co">// set Logical ID. (0xFE means a child device with no ID)</span></a>
<a class="sourceLine" id="cb3-15" title="15">            &lt;&lt; NWK_SIMPLE::repeat_max(<span class="dv">3</span>);   <span class="co">// can repeat a packet up to three times. (being kind of a router)</span></a>
<a class="sourceLine" id="cb3-16" title="16"></a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="co">/*** </span><span class="re">BEGIN</span><span class="co"> section */</span></a>
<a class="sourceLine" id="cb3-18" title="18">    Buttons.begin(pack_bits(PIN_BTN), <span class="dv">5</span>, <span class="dv">10</span>); <span class="co">// check every 10ms, a change is reported by 5 consequent values.</span></a>
<a class="sourceLine" id="cb3-19" title="19">    Analogue.begin(pack_bits(PIN_ANALOGUE::A1, PIN_ANALOGUE::VCC)); <span class="co">// _start continuous adc capture.</span></a>
<a class="sourceLine" id="cb3-20" title="20"></a>
<a class="sourceLine" id="cb3-21" title="21">    the_twelite.begin(); <span class="co">// start twelite!</span></a>
<a class="sourceLine" id="cb3-22" title="22"></a>
<a class="sourceLine" id="cb3-23" title="23">    <span class="co">/*** INIT message */</span></a>
<a class="sourceLine" id="cb3-24" title="24">    Serial &lt;&lt; <span class="st">&quot;--- PingPong sample (press &#39;t&#39; to transmit) ---&quot;</span> &lt;&lt; mwx::crlf;</a>
<a class="sourceLine" id="cb3-25" title="25">}</a></code></pre></div>
<p>大まかな流れは、各部の初期設定、各部の開始となっています。</p>
<h4 id="the_twelite">the_twelite</h4>
<p>このオブジェクトはTWENETを操作するための中核クラスオブジェクトです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1">    <span class="co">// the twelite main class</span></a>
<a class="sourceLine" id="cb4-2" title="2">    the_twelite</a>
<a class="sourceLine" id="cb4-3" title="3">        &lt;&lt; TWENET::appid(APP_ID)    <span class="co">// set application ID (identify network group)</span></a>
<a class="sourceLine" id="cb4-4" title="4">        &lt;&lt; TWENET::channel(CHANNEL) <span class="co">// set channel (pysical channel)</span></a>
<a class="sourceLine" id="cb4-5" title="5">        &lt;&lt; TWENET::rx_when_idle();  <span class="co">// open receive circuit (if not set, it can&#39;t listen packts from others)</span></a></code></pre></div>
<p><code>the_twelite</code> に設定を反映するには <code>&lt;&lt;</code> を用います。</p>
<ul>
<li><code>TWENET::appid(APP_ID)</code> アプリケーションIDの指定</li>
<li><code>TWENET::channel(CHANNEL)</code> チャネルの指定</li>
<li><code>TWENET::rx_when_idle()</code> 受信回路をオープンにする指定</li>
</ul>
<div class="info">
<p><code>&lt;&lt;, &gt;&gt;</code>演算子は本来ビットシフト演算子ですが、その意味合いと違った利用とはなります。MWXライブラリ内では、C++標準ライブラリでの入出力利用に倣ってライブラリ中では上記のような設定やシリアルポートの入出力で利用しています。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// 以下の記述は MWX ライブラリでは利用できません。</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hello world&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</a></code></pre></div>
</div>
<p>次にネットワークを登録します。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">auto</span>&amp;&amp; nwksmpl = the_twelite.network.use&lt;NWK_SIMPLE&gt;();</a>
<a class="sourceLine" id="cb6-2" title="2">nwksmpl &lt;&lt; NWK_SIMPLE::logical_id(<span class="bn">0xFE</span>);</a>
<a class="sourceLine" id="cb6-3" title="3">        &lt;&lt; NWK_SIMPLE::repeat_max(<span class="dv">3</span>);</a></code></pre></div>
<p>1行目は、ボードの登録と同じ書き方で <code>&lt;&gt;</code> には <code>&lt;NWK_SIMPLE&gt;</code>を指定します。</p>
<p>2行目は、<code>&lt;NWK_SIMPLE&gt;</code>の設定で、<code>0xFE</code>(<strong>ID未設定の子機</strong>)という指定を行います。</p>
<p>3行目は、中継回数の最大値を指定しています。この解説では中継には触れませんが、複数台で動作させたときにパケットの中継が行われます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1">the_twelite.begin(); <span class="co">// start twelite!</span></a></code></pre></div>
<p><code>setup()</code> 関数の末尾で <code>the_twelite.begin()</code> を実行しています。</p>
<h4 id="analogue">Analogue</h4>
<p>ADC(アナログディジタルコンバータ)を取り扱うクラスオブジェクトです。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1">Analogue.setup(<span class="kw">true</span>);</a></code></pre></div>
<p>初期化<code>Analogue.setup()</code>で行います。パラメータの<code>true</code>はADC回路の安定までその場で待つ指定です。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1">Analogue.begin(pack_bits(PIN_ANALOGUE::A1, PIN_ANALOGUE::VCC), <span class="dv">50</span>); </a></code></pre></div>
<p>ADCを開始するには<code>Analogue.begin()</code>を呼びます。パラメータはADC対象のピンに対応するビットマップです。</p>
<p>ビットマップを指定するのに<code>pack_bits()</code>関数を用います。可変数引数の関数で、各引数には１を設定するビット位置を指定します。例えば<code>pack_bits(1,3,5)</code>なら２進数で <code>101010</code>の値が戻ります。この関数は<code>constexpr</code>指定があるため、パラメータが定数のみであれば定数に展開されます。</p>
<p>パラメータには<code>PIN_ANALOGUE::A1</code>（ADC0）と<code>PIN_ANALOGUE::VCC</code>（モジュール電源電圧）が指定されています。</p>
<p>2番目のパラメータには<code>50</code>が指定されています。ADCの動作はデフォルトではTickTimerで開始されていて、</p>
<div class="info">
<p>初回を除き ADC の開始は、割り込みハンドラ内で行います。</p>
</div>
<h4 id="buttons">Buttons</h4>
<p>DIO (ディジタル入力) の値の変化を検出します。Buttonsでは、メカ式のボタンのチャタリング（摺動）の影響を軽減するため、一定回数同じ値が検出されてから、値の変化とします。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1">Buttons.setup(<span class="dv">5</span>);</a></code></pre></div>
<p>初期化は <code>Buttons.setup()</code>で行います。パラメータの 5 は、値の確定に必要な検出回数ですが、設定可能な最大値を指定します。内部的にはこの数値をもとに内部メモリの確保を行っています。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1">Buttons.begin(pack_bits(PIN_BTN),</a>
<a class="sourceLine" id="cb11-2" title="2">                    <span class="dv">5</span>,      <span class="co">// history count</span></a>
<a class="sourceLine" id="cb11-3" title="3">                    <span class="dv">10</span>);    <span class="co">// tick delta</span></a></code></pre></div>
<p>開始は <code>Buttons.begin()</code> で行います。１番目のパラメータは検出対象のDIOです。<code>BRD_APPTWELITE::</code>に定義される<code>PIN_BTN</code> (12) を指定しています。２番めのパラメータは状態を確定するのに必要な検出回数です。３番めのパラメータは検出間隔です。<code>10</code>を指定しているので10msごとに5回連続で同じ値が検出できた時点で、HIGH, LOWの状態が確定します。</p>
<div class="info">
<p>ButtonsでのDIO状態の検出はイベントハンドラで行います。イベントハンドラは、割り込み発生後にアプリケーションループで呼ばれるため割り込みハンドラに比べ遅延が発生します。</p>
</div>
<h4 id="serial">Serial</h4>
<p>Serial オブジェクトは、初期化や開始手続きなく利用できます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1">Serial &lt;&lt; <span class="st">&quot;--- PingPong sample (press &#39;t&#39; to transmit) ---&quot;</span> &lt;&lt; mwx::crlf;</a></code></pre></div>
<p>シリアルポートへの文字列出力を行います。<code>mwx::crlf</code>は改行文字です。</p>
<h3 id="ループ-loop">ループ loop()</h3>
<p>ループ関数は TWENET ライブラリのメインループからコールバック関数として呼び出されます。ここでは、利用するオブジェクトが available になるのを待って、その処理を行うのが基本的な記述です。ここではアクトで使用されているいくつかのオブジェクトの利用について解説します。</p>
<div class="warning">
<p>TWENET ライブラリのメインループは、事前にFIFOキューに格納された受信パケットや割り込み情報などをイベントとして処理し、そののち<code>loop()</code>が呼び出されます。<code>loop()</code>を抜けた後は CPU が DOZE モードに入り、低消費電流で新たな割り込みが発生するまでは待機します。</p>
<p>したがってCPUが常に稼働していることを前提としたコードはうまく動作しません。</p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">void</span> loop() {</a>
<a class="sourceLine" id="cb13-2" title="2">      <span class="co">// read from serial</span></a>
<a class="sourceLine" id="cb13-3" title="3">        <span class="cf">while</span>(Serial.available())  {</a>
<a class="sourceLine" id="cb13-4" title="4">                <span class="dt">int</span> c = Serial.read();</a>
<a class="sourceLine" id="cb13-5" title="5">                Serial &lt;&lt; mwx::crlf &lt;&lt; <span class="dt">char</span>(c) &lt;&lt; <span class="ch">&#39;:&#39;</span>;</a>
<a class="sourceLine" id="cb13-6" title="6">                <span class="cf">switch</span>(c) {</a>
<a class="sourceLine" id="cb13-7" title="7">                    <span class="cf">case</span> <span class="ch">&#39;t&#39;</span>:</a>
<a class="sourceLine" id="cb13-8" title="8">                          vTransmit(MSG_PING, <span class="bn">0xFF</span>);</a>
<a class="sourceLine" id="cb13-9" title="9">                        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb13-10" title="10">                    <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb13-11" title="11">                              <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb13-12" title="12">                }</a>
<a class="sourceLine" id="cb13-13" title="13">        }</a>
<a class="sourceLine" id="cb13-14" title="14"></a>
<a class="sourceLine" id="cb13-15" title="15"></a>
<a class="sourceLine" id="cb13-16" title="16">    <span class="co">// Button press</span></a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="cf">if</span> (Buttons.available()) {</a>
<a class="sourceLine" id="cb13-18" title="18">        <span class="dt">uint32_t</span> btn_state, change_mask;</a>
<a class="sourceLine" id="cb13-19" title="19">        Buttons.read(btn_state, change_mask);</a>
<a class="sourceLine" id="cb13-20" title="20"></a>
<a class="sourceLine" id="cb13-21" title="21">        <span class="co">// Serial &lt;&lt; fmt(&quot;&lt;BTN %b:%b&gt;&quot;, btn_state, change_mask);</span></a>
<a class="sourceLine" id="cb13-22" title="22">        <span class="cf">if</span> (!(change_mask &amp; <span class="bn">0x80000000</span>) &amp;&amp; (btn_state &amp;&amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; PIN_BTN))) {</a>
<a class="sourceLine" id="cb13-23" title="23">            <span class="co">// PIN_BTN pressed</span></a>
<a class="sourceLine" id="cb13-24" title="24">            vTransmit(MSG_PING, <span class="bn">0xFF</span>);</a>
<a class="sourceLine" id="cb13-25" title="25">        }</a>
<a class="sourceLine" id="cb13-26" title="26">    }</a>
<a class="sourceLine" id="cb13-27" title="27">}</a></code></pre></div>
<h4 id="serial-1">Serial</h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1">        <span class="cf">while</span>(Serial.available())  {</a>
<a class="sourceLine" id="cb14-2" title="2">                <span class="dt">int</span> c = Serial.read();</a>
<a class="sourceLine" id="cb14-3" title="3">                Serial &lt;&lt; mwx::crlf &lt;&lt; <span class="dt">char</span>(c) &lt;&lt; <span class="ch">&#39;:&#39;</span>;</a>
<a class="sourceLine" id="cb14-4" title="4">                <span class="cf">switch</span>(c) {</a>
<a class="sourceLine" id="cb14-5" title="5">                    <span class="cf">case</span> <span class="ch">&#39;t&#39;</span>:</a>
<a class="sourceLine" id="cb14-6" title="6">                          vTransmit(MSG_PING, <span class="bn">0xFF</span>);</a>
<a class="sourceLine" id="cb14-7" title="7">                        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb14-8" title="8">                    <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb14-9" title="9">                              <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb14-10" title="10">                }</a>
<a class="sourceLine" id="cb14-11" title="11">        }</a></code></pre></div>
<p><code>Serial.available()</code>が<code>true</code>の間はシリアルポートからの入力があります。内部のFIFOキューに格納されるためある程度の余裕はありますが、速やかに読み出すようにします。データの読み出しは<code>Serial.read()</code>を呼びます。</p>
<p>ここでは<code>&#39;t&#39;</code>キーの入力に対応して<code>vTransmit()</code>関数を呼び出しPINGパケットを送信します。</p>
<h4 id="buttons-1">Buttons</h4>
<p>DIO(ディジタルIO)の入力変化を検出したタイミングで available になり、<code>Buttons.read()</code>により読み出します。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1">    <span class="cf">if</span> (Buttons.available()) {</a>
<a class="sourceLine" id="cb15-2" title="2">        <span class="dt">uint32_t</span> btn_state, change_mask;</a>
<a class="sourceLine" id="cb15-3" title="3">        Buttons.read(btn_state, change_mask);</a></code></pre></div>
<p>１番目のパラメータは、現在のDIOのHIGH/LOWのビットマップで、bit0から順番にDIO0,1,2,.. と並びます。例えば DIO12 であれば <code>btn_state &amp; (1UL &lt;&lt; 12)</code> を評価すれば HIGH / LOW が判定できます。ビットが1になっているものがHIGHになります。</p>
<div class="info">
<p>初回のIO状態確定時は MSB (bit31) に１がセットされます。スリープ復帰時も初回の確定処理を行います。</p>
</div>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="co">// Serial &lt;&lt; fmt(&quot;&lt;BTN %b:%b&gt;&quot;, btn_state, change_mask);</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="cf">if</span> (!(change_mask &amp; <span class="bn">0x80000000</span>) &amp;&amp; (btn_state &amp;&amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; PIN_BTN))) {</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="co">// PIN_BTN pressed</span></a>
<a class="sourceLine" id="cb16-4" title="4">    vTransmit(MSG_PING, <span class="bn">0xFF</span>);</a></code></pre></div>
<p>初回確定以外の場合かつPIN_BTNのボタンが<strong>離された</strong>タイミングで<code>vTransmit()</code>を呼び出しています。押したタイミングにするには<code>(!(btn_state &amp;&amp; (1UL &lt;&lt; PIN_BTN)))</code>のように条件を論理反転します。</p>
<h3 id="transmit">transmit()</h3>
<p>無線パケットの送信要求をTWENETに行う関数です。本関数が終了した時点では、まだ無線パケットの処理は行われません。実際に送信が完了するのは、送信パラメータ次第ですが、数ms後以降になります。ここでは代表的な送信要求方法について解説します。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">void</span> vTransmit(<span class="at">const</span> <span class="dt">char</span>* msg, <span class="dt">uint32_t</span> addr) {</a>
<a class="sourceLine" id="cb17-2" title="2">    Serial &lt;&lt; <span class="st">&quot;vTransmit()&quot;</span> &lt;&lt; mwx::crlf;</a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="cf">if</span> (<span class="kw">auto</span>&amp;&amp; pkt = the_twelite.network.use&lt;NWK_SIMPLE&gt;().prepare_tx_packet()) {</a>
<a class="sourceLine" id="cb17-5" title="5">        <span class="co">// set tx packet behavior</span></a>
<a class="sourceLine" id="cb17-6" title="6">        pkt &lt;&lt; tx_addr(addr)  <span class="co">// 0..0xFF (LID 0:parent, FE:child w/ no id, FF:LID broad cast), 0x8XXXXXXX (long address)</span></a>
<a class="sourceLine" id="cb17-7" title="7">            &lt;&lt; tx_retry(<span class="bn">0x3</span>) <span class="co">// set retry (0x3 send four times in total)</span></a>
<a class="sourceLine" id="cb17-8" title="8">            &lt;&lt; tx_packet_delay(<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">20</span>); <span class="co">// send packet w/ delay (send first packet with randomized delay from 100 to 200ms, repeat every 20ms)</span></a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10">        <span class="co">// prepare packet payload</span></a>
<a class="sourceLine" id="cb17-11" title="11">        pack_bytes(pkt.get_payload() <span class="co">// set payload data objects.</span></a>
<a class="sourceLine" id="cb17-12" title="12">            , make_pair(msg, MSG_LEN) <span class="co">// string should be paired with length explicitly.</span></a>
<a class="sourceLine" id="cb17-13" title="13">            , <span class="dt">uint16_t</span>(analogRead(PIN_ANALOGUE::A1)) <span class="co">// possible numerical values types are uint8_t, uint16_t, uint32_t. (do not put other types)</span></a>
<a class="sourceLine" id="cb17-14" title="14">            , <span class="dt">uint16_t</span>(analogRead_mv(PIN_ANALOGUE::VCC)) <span class="co">// A1 and VCC values (note: alalog read is valid after the first (Analogue.available() == true).)</span></a>
<a class="sourceLine" id="cb17-15" title="15">            , <span class="dt">uint32_t</span>(millis()) <span class="co">// put timestamp here.</span></a>
<a class="sourceLine" id="cb17-16" title="16">        );</a>
<a class="sourceLine" id="cb17-17" title="17">    </a>
<a class="sourceLine" id="cb17-18" title="18">        <span class="co">// do transmit </span></a>
<a class="sourceLine" id="cb17-19" title="19">        pkt.transmit();</a>
<a class="sourceLine" id="cb17-20" title="20">    }</a>
<a class="sourceLine" id="cb17-21" title="21">}</a></code></pre></div>
<h4 id="section"></h4>
<h4 id="ネットワークオブジェクトとパケットオブジェクトの取得">ネットワークオブジェクトとパケットオブジェクトの取得</h4>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1">    <span class="cf">if</span> (<span class="kw">auto</span>&amp;&amp; pkt = the_twelite.network.use&lt;NWK_SIMPLE&gt;().prepare_tx_packet()) {</a></code></pre></div>
<p>ネットワークオブジェクトを<code>the_twelite.network.use&lt;NWK_SIMPLE&gt;()</code>で取得します。そのオブジェクトを用いて<code>.prepare_tx_packet()</code>により<code>pkt</code>オブジェクトを取得します。</p>
<p>ここではif文の条件判定式の中で宣言しています。宣言した<code>pkt</code>オブジェクトはif節の終わりまで有効です。pktオブジェクトはbool型の応答をし、ここではTWENETの送信要求キューに空きがあって送信要求を受け付ける場合に<code>true</code>、空きがない場合に<code>false</code>となります。</p>
<h4 id="パケットの送信設定">パケットの送信設定</h4>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1">        pkt &lt;&lt; tx_addr(addr)  <span class="co">// 0..0xFF (LID 0:parent, FE:child w/ no id, FF:LID broad cast), 0x8XXXXXXX (long address)</span></a>
<a class="sourceLine" id="cb19-2" title="2">            &lt;&lt; tx_retry(<span class="bn">0x3</span>) <span class="co">// set retry (0x3 send four times in total)</span></a>
<a class="sourceLine" id="cb19-3" title="3">            &lt;&lt; tx_packet_delay(<span class="dv">100</span>,<span class="dv">200</span>,<span class="dv">20</span>); <span class="co">// send packet w/ delay (send first packet with randomized delay from 100 to 200ms, repeat every 20ms)</span></a></code></pre></div>
<p>パケットの設定は<code>the_twelite</code>の初期化設定のように<code>&lt;&lt;</code>演算子を用いて行います。</p>
<ul>
<li><code>tx_addr()</code> パラメータに送信先アドレスを指定します。<code>0x00</code>なら自分が子機で親機宛に、<code>0xFE</code>なら自分が親機で任意の子機宛のブロードキャストという意味です。</li>
<li><code>tx_retry()</code> パラメータに再送回数を指定します。例の<code>3</code>は再送回数が3回、つまり合計4回パケットを送ります。無線パケット１回のみの送信では条件が良くても数％程度の失敗はあります。</li>
<li><code>tx_packet_delay()</code> 送信遅延を設定します。一つ目のパラメータは、送信開始までの最低待ち時間、２番目が最長の待ち時間です。この場合は送信要求を発行後におよそ100msから200msの間で送信を開始します。３番目が再送間隔です。最初のパケットが送信されてから20ms置きに再送を行うという意味です。</li>
</ul>
<h4 id="パケットのデータペイロード">パケットのデータペイロード</h4>
<p>ペイロードは積載物という意味ですが、無線パケットでは「送りたいデータ本体」という意味でよく使われます。無線パケットのデータにはデータ本体以外にもアドレス情報などいくつかの補助情報が含まれます。</p>
<p>送受信を正しく行うために、データペイロードのデータ並び順を意識するようにしてください。ここでは以下のようなデータ順とします。このデータ順に合わせてデータペイロードを構築します。</p>
<pre><code># 先頭バイトのインデックス: データ型 : バイト数 : 内容

00: uint8_t[4] : 4 : ４文字識別子
08: uint16_t   : 2 : AI1のADC値 (0..1023)
06: uint16_t   : 2 : Vccの電圧値 (2000..3600)
10: uint32_t   : 4 : millis()システム時間</code></pre>
<div class="info">
<p>データペイロードには90バイト格納できます（実際にはあと数バイト格納できます）。</p>
<p>IEEE802.15.4の無線パケットの１バイトは貴重です。できるだけ節約して使用することを推奨します。１パケットで送信できるデータ量に限りがあります。パケットを分割する場合は分割パケットの送信失敗などを考慮する必要がありコストは大きくつきます。また１バイト余分に送信するのに、およそ16μ秒×送信時の電流に相当するエネルギーが消費され、特に電池駆動のアプリケーションには大きく影響します。</p>
</div>
<p>上記のデータペイロードのデータ構造を実際に構築してみます。データペイロードは <code>pkt.get_payload()</code> により <code>simplbuf&lt;uint8_t&gt;</code> 型のコンテナとして参照できます。このコンテナに上記の仕様に基づいてデータを構築します。</p>
<p>上記のように記述できますがMWXライブラリでは、データペイロード構築のための補助関数<code>pack_bytes()</code>を用意しています。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="co">// prepare packet payload</span></a>
<a class="sourceLine" id="cb21-2" title="2">pack_bytes(pkt.get_payload() <span class="co">// set payload data objects.</span></a>
<a class="sourceLine" id="cb21-3" title="3">    , make_pair(msg, MSG_LEN) <span class="co">// string should be paired with length explicitly.</span></a>
<a class="sourceLine" id="cb21-4" title="4">    , <span class="dt">uint16_t</span>(analogRead(PIN_ANALOGUE::A1)) <span class="co">// possible numerical values types are uint8_t, uint16_t, uint32_t. (do not put other types)</span></a>
<a class="sourceLine" id="cb21-5" title="5">    , <span class="dt">uint16_t</span>(analogRead_mv(PIN_ANALOGUE::VCC)) <span class="co">// A1 and VCC values (note: alalog read is valid after the first (Analogue.available() == true).)</span></a>
<a class="sourceLine" id="cb21-6" title="6">    , <span class="dt">uint32_t</span>(millis()) <span class="co">// put timestamp here.</span></a>
<a class="sourceLine" id="cb21-7" title="7">);</a></code></pre></div>
<p><code>pack_bytes</code>の最初のパラメータはコンテナを指定します。この場合は<code>pkt.get_payload()</code>です。</p>
<p>そのあとのパラメータは可変数引数で<code>pack_bytes</code>で対応する型の値を必要な数だけ指定します。<code>pack_bytes</code>は内部で<code>.push_back()</code>メソッドを呼び出して末尾に指定した値を追記していきます。</p>
<p>3行目の<code>make_pair()</code>は標準ライブラリの関数で<code>std::pair</code>を生成します。文字列型の混乱（具体的にはペイロードの格納時にヌル文字を含めるか含めないか）を避けるための指定です。<code>make_pair()</code>の1番目のパラメータに文字列型(<code>char*</code>や<code>uint8_t*</code>型、<code>uint8_t[]</code>など)を指定します。2番目のパラメータはペイロードへの格納バイト数です。</p>
<p>4,5,6行目は、数値型の値 (<code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>)を格納します。符号付などの数値型、<code>char</code>型など同じ数値型であっても左記の3つの型にキャストして投入します。</p>
<p><code>analogRead()</code>と<code>analogRead_mv()</code>は、ADCの結果を取得するものです。前者はADC値(0..1023)、後者は電圧[mv](0..2470)となります。モジュールの電源電圧は内部的に分圧抵抗の値を読んでいるためその変換を行う<code>adalogRead_mv()</code>を利用しています。</p>
<p>これでパケットの準備は終わりです。あとは、送信要求を行います。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1">pkt.transmit();</a></code></pre></div>
<p>パケットを送信するには<code>pkt</code>オブジェクトの<code>pkt.transmit()</code>メソッドを用います。</p>
<div class="info">
<p>このアクトでは使用しませんが、戻り値には、要求の成功失敗の情報と要求に対応する番号が格納されています。送信完了まで待つ処理を行う場合は、この戻り値の値を利用します。</p>
</div>
<h3 id="on_rx_packet">on_rx_packet()</h3>
<p>受信パケットがある場合の処理です。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">void</span> on_rx_packet(packet_rx&amp; rx, <span class="dt">bool_t</span> &amp;handled) {</a>
<a class="sourceLine" id="cb23-2" title="2">        <span class="dt">uint8_t</span> msg[MSG_LEN];</a>
<a class="sourceLine" id="cb23-3" title="3">        <span class="dt">uint16_t</span> adcval, volt;</a>
<a class="sourceLine" id="cb23-4" title="4">        <span class="dt">uint32_t</span> timestamp;</a>
<a class="sourceLine" id="cb23-5" title="5"></a>
<a class="sourceLine" id="cb23-6" title="6">        <span class="co">// expand packet payload (shall match with sent packet data structure, see pack_bytes())</span></a>
<a class="sourceLine" id="cb23-7" title="7">        expand_bytes(rx.get_payload().begin(), rx.get_payload().end()</a>
<a class="sourceLine" id="cb23-8" title="8">                    , msg       <span class="co">// 4bytes of msg</span></a>
<a class="sourceLine" id="cb23-9" title="9">                                            <span class="co">//   also can be -&gt; std::make_pair(&amp;msg[0], MSG_LEN)</span></a>
<a class="sourceLine" id="cb23-10" title="10">                    , adcval    <span class="co">// 2bytes, A1 value [0..1023]</span></a>
<a class="sourceLine" id="cb23-11" title="11">                  , volt      <span class="co">// 2bytes, Module VCC[mV]</span></a>
<a class="sourceLine" id="cb23-12" title="12">                    , timestamp <span class="co">// 4bytes of timestamp</span></a>
<a class="sourceLine" id="cb23-13" title="13">        );</a>
<a class="sourceLine" id="cb23-14" title="14">        </a>
<a class="sourceLine" id="cb23-15" title="15">        <span class="co">// if PING packet, respond pong!</span></a>
<a class="sourceLine" id="cb23-16" title="16">    <span class="cf">if</span> (!strncmp((<span class="at">const</span> <span class="dt">char</span>*)msg, <span class="st">&quot;PING&quot;</span>, MSG_LEN)) {</a>
<a class="sourceLine" id="cb23-17" title="17">                <span class="co">// transmit a PONG packet with specifying the address.</span></a>
<a class="sourceLine" id="cb23-18" title="18">        vTransmit(MSG_PONG, rx.get_psRxDataApp()-&gt;u32SrcAddr);</a>
<a class="sourceLine" id="cb23-19" title="19">    }</a>
<a class="sourceLine" id="cb23-20" title="20"></a>
<a class="sourceLine" id="cb23-21" title="21">        <span class="co">// display the packet</span></a>
<a class="sourceLine" id="cb23-22" title="22">        Serial &lt;&lt; format(<span class="st">&quot;&lt;RX ad=</span><span class="sc">%x</span><span class="st">/lq=</span><span class="sc">%d</span><span class="st">/ln=</span><span class="sc">%d</span><span class="st">/sq=</span><span class="sc">%d</span><span class="st">:&quot;</span> <span class="co">// note: up to 4 args!</span></a>
<a class="sourceLine" id="cb23-23" title="23">                    , rx.get_psRxDataApp()-&gt;u<span class="dv">32</span><span class="er">SrcAddr</span></a>
<a class="sourceLine" id="cb23-24" title="24">                    , rx.get_lqi()</a>
<a class="sourceLine" id="cb23-25" title="25">                    , rx.get_length()</a>
<a class="sourceLine" id="cb23-26" title="26">                    , rx.get_psRxDataApp()-&gt;u<span class="dv">8</span><span class="er">Seq</span></a>
<a class="sourceLine" id="cb23-27" title="27">                    )</a>
<a class="sourceLine" id="cb23-28" title="28">                &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%s</span><span class="st"> AD=</span><span class="sc">%d</span><span class="st"> V=</span><span class="sc">%d</span><span class="st"> TS=</span><span class="sc">%d</span><span class="st">ms&gt;&quot;</span> <span class="co">// note: up to 4 args!</span></a>
<a class="sourceLine" id="cb23-29" title="29">                    , msg</a>
<a class="sourceLine" id="cb23-30" title="30">                    , adcval</a>
<a class="sourceLine" id="cb23-31" title="31">                    , volt</a>
<a class="sourceLine" id="cb23-32" title="32">                    , timestamp</a>
<a class="sourceLine" id="cb23-33" title="33">                    )</a>
<a class="sourceLine" id="cb23-34" title="34">               &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb23-35" title="35">               &lt;&lt; mwx::flush;</a>
<a class="sourceLine" id="cb23-36" title="36">    }</a></code></pre></div>
<p>まず受信パケットのデータはパラメータ<code>rx</code>として渡されます。<code>rx</code>から無線パケットのアドレス情報やデータペイロードにアクセスします。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="cf">while</span> (the_twelite.receiver.available()) {</a>
<a class="sourceLine" id="cb24-2" title="2">        <span class="kw">auto</span>&amp;&amp; rx = the_twelite.receiver.read();</a></code></pre></div>
<p>次の行では、受信パケットデータには、送信元のアドレス（32bitのロングアドレスと8bitの論理アドレス）などの情報を参照しています。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1">Serial &lt;&lt; format(<span class="st">&quot;..receive(%08x/</span><span class="sc">%d</span><span class="st">) : &quot;</span>,</a>
<a class="sourceLine" id="cb25-2" title="2">   rx.get_addr_src_long(), rx.get_addr_src_lid());</a></code></pre></div>
<div class="info">
<p><code>&lt;NWK_SIMPLE&gt;</code>では、8bitの論理IDと32bitのロングアドレスの２種類が常にやり取りされます。送り先を指定する場合はロングアドレスか論理アドレスのいずれかを指定します。受信時には両方のアドレスが含まれます。</p>
</div>
<p>MWXライブラリには<code>transmit()</code>の時に使った<code>pack_bytes()</code>の対になる関数<code>expand_bytes()</code>が用意されています。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">uint8_t</span> msg[MSG_LEN];</a>
<a class="sourceLine" id="cb26-2" title="2"><span class="dt">uint16_t</span> adcval, volt;</a>
<a class="sourceLine" id="cb26-3" title="3"><span class="dt">uint32_t</span> timestamp;</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">// expand packet payload (shall match with sent packet data structure, see pack_bytes())</span></a>
<a class="sourceLine" id="cb26-6" title="6">expand_bytes(rx.get_payload().begin(), rx.get_payload().end()</a>
<a class="sourceLine" id="cb26-7" title="7">        , msg       <span class="co">// 4bytes of msg</span></a>
<a class="sourceLine" id="cb26-8" title="8">                                <span class="co">//   also can be -&gt; std::make_pair(&amp;msg[0], MSG_LEN)</span></a>
<a class="sourceLine" id="cb26-9" title="9">        , adcval    <span class="co">// 2bytes, A1 value [0..1023]</span></a>
<a class="sourceLine" id="cb26-10" title="10">      , volt      <span class="co">// 2bytes, Module VCC[mV]</span></a>
<a class="sourceLine" id="cb26-11" title="11">        , timestamp <span class="co">// 4bytes of timestamp</span></a>
<a class="sourceLine" id="cb26-12" title="12">    );</a></code></pre></div>
<p>1行目から3行目までは、データを格納する変数を指定しています。</p>
<p>6行目で<code>expand_bytes()</code>によりパケットのペイロードのデータを変数に格納します。1番目のパラメータでコンテナの先頭イテレータ（<code>uint8_t*</code>ポインタ）を指定します。<code>.begin()</code>メソッドにより取得できます。2番目のパラメータはコンテナの末尾の次を指すイテレータで<code>.end()</code>メソッドで取得できます。2番目はコンテナの末尾を超えた読み出しを行わないようにするためです。</p>
<p>3番目以降のパラメータに変数を列挙します。列挙した順番にペイロードの読み出しとデータ格納が行われます。</p>
<div class="info">
<p>このアクトでは、パケット長が間違っていた場合などのエラーチェックを省いています。チェックを厳格にしたい場合は、<code>expand_bytes()</code>の戻り値により判定してください。</p>
<p><code>expand_bytes()</code>の戻り値は <code>uint8_t*</code> ですが、末尾を超えたアクセスの場合は<code>nullptr（ヌルポインタ）</code>を戻します。</p>
</div>
<p><code>msg</code>に読み出した4バイト文字列の識別子が<code>&quot;PING&quot;</code>の場合はPONGメッセージを送信する処理です。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1"><span class="cf">if</span> (!strncmp((<span class="at">const</span> <span class="dt">char</span>*)msg, <span class="st">&quot;PING&quot;</span>, MSG_LEN)) {</a>
<a class="sourceLine" id="cb27-2" title="2">    vTransmit(MSG_PONG, rx.get_psRxDataApp()-&gt;u32SrcAddr);</a>
<a class="sourceLine" id="cb27-3" title="3">}</a></code></pre></div>
<p>続いて到着したパケット情報を表示します。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1">        Serial &lt;&lt; format(<span class="st">&quot;&lt;RX ad=</span><span class="sc">%x</span><span class="st">/lq=</span><span class="sc">%d</span><span class="st">/ln=</span><span class="sc">%d</span><span class="st">/sq=</span><span class="sc">%d</span><span class="st">:&quot;</span> <span class="co">// note: up to 4 args!</span></a>
<a class="sourceLine" id="cb28-2" title="2">                    , rx.get_psRxDataApp()-&gt;u<span class="dv">32</span><span class="er">SrcAddr</span></a>
<a class="sourceLine" id="cb28-3" title="3">                    , rx.get_lqi()</a>
<a class="sourceLine" id="cb28-4" title="4">                    , rx.get_length()</a>
<a class="sourceLine" id="cb28-5" title="5">                                        , rx.get_psRxDataApp()-&gt;u<span class="dv">8</span><span class="er">Seq</span></a>
<a class="sourceLine" id="cb28-6" title="6">                    )</a>
<a class="sourceLine" id="cb28-7" title="7">           &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%s</span><span class="st"> AD=</span><span class="sc">%d</span><span class="st"> V=</span><span class="sc">%d</span><span class="st"> TS=</span><span class="sc">%d</span><span class="st">ms&gt;&quot;</span> <span class="co">// note: up to 4 args!</span></a>
<a class="sourceLine" id="cb28-8" title="8">                    , msg</a>
<a class="sourceLine" id="cb28-9" title="9">                    , adcval</a>
<a class="sourceLine" id="cb28-10" title="10">                    , volt</a>
<a class="sourceLine" id="cb28-11" title="11">                    , timestamp</a>
<a class="sourceLine" id="cb28-12" title="12">                    )</a>
<a class="sourceLine" id="cb28-13" title="13">         &lt;&lt; mwx::crlf</a>
<a class="sourceLine" id="cb28-14" title="14">               &lt;&lt; mwx::flush;</a></code></pre></div>
<p>数値のフォーマット出力が必要になるので<code>format()</code>を用いています。<code>&gt;&gt;</code>演算子向けに_printf()_と同じ構文を利用できるようにしたヘルパークラスですが、<strong>引数の数は最大8つまで（32bitパラメータの場合)に制限</strong>されています。（制限を超えるとコンパイルエラーが出ます。なお<code>Serial.printfmt()</code>には引数の数の制限がありません。）</p>
<p><code>mwx::crlf</code>は改行文字(CR LF)を、<code>mwx::flush</code>は出力完了待ちを指定します。（<code>mxw::flush</code>は<code>Serial.flush()</code>と記述しても構いません）</p>
</body>
</html>
