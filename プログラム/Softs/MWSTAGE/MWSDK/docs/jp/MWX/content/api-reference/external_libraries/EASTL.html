<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mono Wireless Inc." />
  <title>EASTL</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">EASTL</h1>
<p class="author">Mono Wireless Inc.</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#eastl">EASTL</a><ul>
<li><a href="#twenetでの利用">TWENETでの利用</a><ul>
<li><a href="#組み込みコンパイル方法">組み込み・コンパイル方法</a></li>
<li><a href="#組み込み方法詳細">組み込み方法(詳細)</a></li>
</ul></li>
<li><a href="#コーディングについて">コーディングについて</a><ul>
<li><a href="#std-と-eastl-について"><code>std::</code> と <code>eastl::</code> について</a></li>
<li><a href="#グローバルオブジェクトの初期化1-配置new">グローバルオブジェクトの初期化1 (配置new)</a></li>
<li><a href="#グローバルオブジェクトの初期化2-unique_ptr">グローバルオブジェクトの初期化2 (unique_ptr)</a></li>
<li><a href="#intrusive-コンテナについて">intrusive コンテナについて</a></li>
</ul></li>
<li><a href="#参考資料">参考資料</a></li>
<li><a href="#本サンプルについて">本サンプルについて</a></li>
<li><a href="#コード例">コード例</a><ul>
<li><a href="#fixed_vector">fixed_vector</a></li>
<li><a href="#fixed_list">fixed_list</a></li>
<li><a href="#intrusive_list">intrusive_list</a></li>
<li><a href="#ring_buffer">ring_buffer</a></li>
<li><a href="#intrusive_hash_map">intrusive_hash_map</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="eastl">EASTL</h1>
<p><a target=_blank href="https://github.com/electronicarts/EASTL">EASTL</a> は Electronic Arts 社が整備した標準テンプレートライブラリ(コンテナ・アルゴリズム)で、C++ の STL (Standard Template Library) に倣い実装されていますが、制約の多いゲーム機の開発で整備されてきた経緯があり、メモリの取り扱いに制約が大きい環境を意識したコンテナやアルゴリズムが用意されています。</p>
<p>本ライブラリは EASTL を TWENET 内で利用できるようにしています。</p>
<p>以下はバッファ最大長が固定の配列とソートアルゴリズムの適用です。</p>
<p>以下にEASTLの特徴を記載します。</p>
<ul>
<li>メモリ固定確保のコンテナ (<code>fixed_</code>) : 動的確保を行わず、固定長の要素数を持つコンテナの宣言が可能です。グローバル宣言すれば、コンパイル時に固定的にメモリ領域が確保され、ローカル宣言すればスタックエリアに確保されそのスコープ内で利用できます。</li>
<li>Intrusive コンテナ：通常のコンテナは任意のデータ構造を格納できますが、Intrusiveコンテナはデータ構造に対して専用の基底クラスを継承することで、コンテナ内のリンク構造などを維持するためのリンク情報などを保持します。コンテナ内の各要素はそのコンテナ専用になりますが、リストやマップ構造では非常にメモリ利用効率の良くなります。（参考: <a target=_blank href="https://www.boost.org/doc/libs/1_35_0/doc/html/intrusive/intrusive_vs_nontrusive.html">Intrusive and non-intrusive containers</a>）</li>
</ul>
<p>2007年の記事<a target=_blank href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html">EASTL (open-std.org)</a>に開発動機などが記されています。(関連記事：<a target=_blank href="https://i-saint.hatenablog.com/entry/20101012/1286822888">EASTL から垣間見るゲームソフトウェア開発現場の現状 その 1</a>, <a target=_blank href="https://i-saint.hatenablog.com/entry/20101026/1288028957">その 2</a>)</p>
<h2 id="twenetでの利用">TWENETでの利用</h2>
<p>以下に留意してください。</p>
<p><strong>当社ではライブラリの動作については包括的な検証は行っておりません。お客様での動作検証をお願いいたします。また EASTL の利用方法についてのお問い合わせについても当社では対応できません。配布元の開設資料・ライブラリソースコードなどの情報を参照してください。</strong></p>
<ul>
<li><a target=_blank href="https://github.com/electronicarts/EASTL/releases/tag/3.07.00">EASTL3.07</a> (2018/1/31) のバージョンを利用します。（C++11でコンパイルできる一番最後のバージョン）</li>
<li>以下のライブラリは組み込んでいません。
<ul>
<li><code>test/packages/EAAssert</code>, <code>source/assert.cpp</code></li>
<li><code>test/packages/EATest</code></li>
<li><code>test/packages/EAThread</code>, <code>source/thread_support.cpp</code></li>
</ul></li>
<li>テストコード <code>test/source</code> の動作移植はしていません。</li>
<li>_sprintf_関連では<code>EA::StdC::Vsnprintf(char8_t*, ...)</code> のみを printf.h ライブラリ中の <code>vsnprintf_()</code> を呼び出すことで解決しています。</li>
</ul>
<h3 id="組み込みコンパイル方法">組み込み・コンパイル方法</h3>
<p>EASTL はアクト Act の記述の際に利用できます。</p>
<p>TWELITE 向けの開発環境で必要なインクルードパスの追加、ライブラリの追加は行います。作成するコード中でライブラリヘッダのインクルードを行ってください。</p>
<pre><code>#include &lt;TWELITE&gt;
#include &lt;EASTL/fixed_string.h&gt;

using namespace eastl;
using tstr128 = fixed_string&lt;char, 127 + 1, false&gt;;

void setup() {
    tstr128 s1;
    s1 = &quot;Hello World&quot;;
    Serial &lt;&lt; s1.c_str();
}
void loop() {
    ;
}</code></pre>
<h3 id="組み込み方法詳細">組み込み方法(詳細)</h3>
<p>ライブラリのコンパイルやインクルードパスの設定は、MWSDK/TWENET 以下のディレクトリで実施済みですが、内部的な設定を以下に記載します。</p>
<ul>
<li>EASTL/source 内のコードをコンパイルして、ライブラリアーカイブとしておく (<code>libEASTL.a</code>)。リンク時にはこのライブラリの参照が必須です。</li>
<li>コンパイル時に以下のインクルードパスを追加しておく。</li>
</ul>
<p><code>$(PATH_EASTL)</code>を EASTL ディレクトリとした場合、インクルードパスは以下となります。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">-I</span><span class="va">$(</span><span class="ex">PATH_EASTL</span><span class="va">)</span>/include</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">-I</span><span class="va">$(</span><span class="ex">PATH_EASTL</span><span class="va">)</span>/test/packages/EAAssert/include</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ex">-I</span><span class="va">$(</span><span class="ex">PATH_EASTL</span><span class="va">)</span>/test/packages/EABase/include/Common</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ex">-I</span><span class="va">$(</span><span class="ex">PATH_EASTL</span><span class="va">)</span>/test/packages/EAMain/include</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="ex">-I</span><span class="va">$(</span><span class="ex">PATH_EASTL</span><span class="va">)</span>/test/packages/EAStdC/include</a>
<a class="sourceLine" id="cb2-6" title="6"><span class="ex">-I</span><span class="va">$(</span><span class="ex">PATH_EASTL</span><span class="va">)</span>/test/packages/EATest/include</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ex">-I</span><span class="va">$(</span><span class="ex">PATH_EASTL</span><span class="va">)</span>/test/packages/EAThread/include</a></code></pre></div>
<h2 id="コーディングについて">コーディングについて</h2>
<h3 id="std-と-eastl-について"><code>std::</code> と <code>eastl::</code> について</h3>
<p>MWXライブ内部でも <code>std::</code> 名前空間の標準ライブラリを利用しています。</p>
<p>標準ライブラリ (<code>std::</code>) と EASTL(<code>eastl::</code>)では同じ名前で同じ機能を持つものが定義されています。これらは混在できる場合もありますが、使用するとエラーになる場合もあります。つまりEASTLで使用するものは、通常はEASTL内の定義を用います（例：<code>std::unique_ptr</code> に <code>eastl::fixed_string</code> を格納しようとするとコンパイラエラーになります）。</p>
<p>また<code>using namespace std;</code>といったような記述を行う場合は、名前の衝突に注意してください。</p>
<h3 id="グローバルオブジェクトの初期化1-配置new">グローバルオブジェクトの初期化1 (配置new)</h3>
<p>TWENET の開発では、コンパイラの制約により、グローバル宣言のオブジェクトのコンストラクタが実行されません。グローバル宣言宣言したオブジェクトのメモリ領域がゼロクリアされるだけです。そのまま、コードを実行すると大抵の場合 null pointer access によりハングアップします。</p>
<p>このオブジェクトを初期化するためには*placement new (配置new)*を用います。</p>
<pre><code>#include &lt;TWELITE&gt;
#include &lt;EASTL/fixed_string.h&gt;

using namespace eastl;
using tstr128 = fixed_string&lt;char, 127 + 1, false&gt;;

tstr128 g_str1; // constructor is NOT called! needs to be initialized before use.

void setup() {
    (void) new ((void*)&amp;g_str1) tstr128(&quot;Hello World&quot;);
    Serial &lt;&lt; g_str1.c_str();
}</code></pre>
<p><em>placement new</em> のコードは少し乱雑に見えるため、補助関数<code>mwx::pnew()</code> を用意しています。先ほどの例を以下のように書き換えることができます。</p>
<pre><code>(void) new ((void*)&amp;g_str1) tstr128(&quot;Hello World&quot;);
// ↓
mwx::pnew(g_str1, &quot;Hello World&quot;);</code></pre>
<p>※ ２番目の引数以降は可変数で、コンストラクタにそのまま渡されます。</p>
<h3 id="グローバルオブジェクトの初期化2-unique_ptr">グローバルオブジェクトの初期化2 (unique_ptr)</h3>
<p>グローバルオブジェクトの初期化方法として <code>unique_ptr</code>(<a target=_blank href="https://cpprefjp.github.io/reference/memory/unique_ptr.html">std::unique_ptrの解説</a>)を用いる方法もあります。<code>unique_ptr</code>は <code>std::</code> にも <code>eastl::</code> にもありますが、EASTLのクラスでは<code>eastl::</code>のものを使用します。</p>
<p>以下のように初期化のタイミングで <code>.reset()</code> を呼び出します。</p>
<pre><code>#include &lt;TWELITE&gt;
#include &lt;EASTL/unique_ptr.h&gt;
#include &lt;EASTL/fixed_string.h&gt;

using namespace eastl;
using tstr128 = fixed_string&lt;char, 127 + 1, false&gt;;

eastl::unique_ptr&lt;tstr128&gt; uq_str1;

void setup() {
    uq_str1.reset(new tstr128(&quot;Hello World&quot;));
    if (uq_str1) { // true: object is stored.
        Serial &lt;&lt; uq_str1-&gt;c_str();
    }
}</code></pre>
<h3 id="intrusive-コンテナについて">intrusive コンテナについて</h3>
<p>以下の例は <code>intrusive_list</code> の要素定義例です。メンバーは <code>int mX</code> のみです。</p>
<pre><code>struct IntNode : public eastl::intrusive_list_node { 
    int mX;
    IntNode(int x = 0) : mX(x) { }
        // no need to call super class&#39;s constructor eastl::intrusive_list_node()
};

inline bool operator&lt;(const IntNode&amp; a, const IntNode&amp; b) { return a.mX &lt; b.mX; }
inline bool operator&gt;(const IntNode&amp; a, const IntNode&amp; b) { return a.mX &gt; b.mX; }</code></pre>
<p><code>intrusive_list</code>の要素は、必ず <code>intrusive_list_node</code> を基底クラスに持っている必要があります。基底クラス内にはリストを維持するためのリンクポインタが含まれます。ここではさらに <code>sort</code>などで使用する比較演算子の定義も行います。</p>
<pre><code>using tiList = intrusive_list&lt;IntNode&gt;;

void setup() {
    IntNode nodeA(5);
    IntNode nodeB(1);
    IntNode nodeC(9);
    IntNode nodeD(2);
    IntNode nodeE(4);

    tiList l; // intrusive_list body
    
    l.push_front(nodeA); // forming list strucure 
                         //   by updating link info in intrusive_list_node.
    l.push_front(nodeB);
    l.push_front(nodeC);
    l.push_front(nodeD);
    l.push_front(nodeE);
    
    l.sort(); // sort, using &lt; operator
    l.sort(eastl::greater&lt;tilist::value_type&gt;()); // sort, using &gt; operator
}</code></pre>
<h2 id="参考資料">参考資料</h2>
<ul>
<li><a target=_blank href="https://eastl.docsforge.com/">EA Standard Template Library</a> ーTWENET に収録されているライブラリは EASTL 3.07 用で、それ以降に実装・変更された要素が含む点に注意してください）</li>
<li><a target=_blank href="https://cpprefjp.github.io/">cpprefjp - C++日本語リファレンス</a> ーC++ リファレンスですが STL の解説が参考になります。</li>
</ul>
<h2 id="本サンプルについて">本サンプルについて</h2>
<p>EASTLのライセンス記述は以下です。</p>
<p><em>Modified BSD License (3-Clause BSD license) see the file LICENSE in the project root.</em></p>
<pre><code>/*
Copyright (C) 2015 Electronic Arts Inc.  All rights reserved.
  
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
  
1.  Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
2.  Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
3.  Neither the name of Electronic Arts, Inc. (&quot;EA&quot;) nor the names of
    its contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.
  
THIS SOFTWARE IS PROVIDED BY ELECTRONIC ARTS AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS OR ITS CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/</code></pre>
<p>サンプルコードは MWSLA-1J/E を適用します。</p>
<h2 id="コード例">コード例</h2>
<h3 id="fixed_vector">fixed_vector</h3>
<p>最大長が固定された（つまり拡張しない）配列。 （※ <code>mwx::smplbuf</code>も同様に最大長固定の配列ですが、MWXライブラリの内部処理に一部特化しています)</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="pp">#include </span><span class="im">&lt;EASTL/fixed_vector.h&gt;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="pp">#include </span><span class="im">&lt;EASTL/sort.h&gt;</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">using</span> tvct = eastl::fixed_vector&lt;<span class="dt">uint16_t</span>, <span class="dv">64</span>, <span class="kw">false</span>&gt;;</a>
<a class="sourceLine" id="cb9-6" title="6">tvct v;</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb9-9" title="9">    mwx::pnew(v); <span class="co">// initialize</span></a>
<a class="sourceLine" id="cb9-10" title="10">    v = { <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span> ,<span class="dv">4</span> }; <span class="co">// set initial list.</span></a>
<a class="sourceLine" id="cb9-11" title="11"></a>
<a class="sourceLine" id="cb9-12" title="12">    <span class="co">// push and pop</span></a>
<a class="sourceLine" id="cb9-13" title="13">    v.pop_back();   <span class="co">// 3, 1, 2</span></a>
<a class="sourceLine" id="cb9-14" title="14">    v.push_back(<span class="dv">5</span>); <span class="co">// 3, 1, 2, 5</span></a>
<a class="sourceLine" id="cb9-15" title="15">    </a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="co">// sort</span></a>
<a class="sourceLine" id="cb9-17" title="17">    eastl::sort(v.begin(), v.end(), eastl::less&lt;tvct::<span class="dt">value_type</span>&gt;());</a>
<a class="sourceLine" id="cb9-18" title="18">                    <span class="co">// 1, 2, 3, 5</span></a>
<a class="sourceLine" id="cb9-19" title="19">    </a>
<a class="sourceLine" id="cb9-20" title="20">    <span class="co">// disp all</span></a>
<a class="sourceLine" id="cb9-21" title="21">    <span class="cf">for</span> (<span class="kw">auto</span> x : v) { Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x); }</a>
<a class="sourceLine" id="cb9-22" title="22">    Serial &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb9-23" title="23">    <span class="co">// using [] operator</span></a>
<a class="sourceLine" id="cb9-24" title="24">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; v.size(); i++) { Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, v[i]); }</a>
<a class="sourceLine" id="cb9-25" title="25">}</a></code></pre></div>
<p><code>fixed_vector</code> のテンプレート引数は３つあり、１番目が型、２番目が最大数、３番目は_false_にします。 配列の操作については、一般の <code>std::vector</code> と類似した <code>.puch_back()</code> や <code>.pop_back()</code>、<code>[]演算子</code>などが利用できます。</p>
<p>また、ソートアルゴリズムなどの適用も可能です。上記の例では <code>eastl::sort</code> を昇順 <code>eastl::less</code> にて行っています。</p>
<h3 id="fixed_list">fixed_list</h3>
<p>最大エレメント数が固定されたリスト構造(intrusive_list についても要参照)。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="pp">#include </span><span class="im">&lt;EASTL/fixed_list.h&gt;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="pp">#include </span><span class="im">&lt;EASTL/sort.h&gt;</span></a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">using</span> tdata = eastl::pair&lt;<span class="dt">uint8_t</span>, <span class="dt">void</span> (*)(<span class="dt">uint8_t</span>)&gt;; <span class="co">// element data type</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">using</span> tlst = eastl::fixed_list&lt;tdata, <span class="dv">3</span>, <span class="kw">false</span>&gt;; <span class="co">// fixed_list with 3 elements.</span></a>
<a class="sourceLine" id="cb10-7" title="7">tlst l; <span class="co">// list object</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb10-10" title="10">    mwx::pnew(l); <span class="co">// initialize (call constructor)</span></a>
<a class="sourceLine" id="cb10-11" title="11">    <span class="co">// add</span></a>
<a class="sourceLine" id="cb10-12" title="12">    <span class="cf">if</span> (!l.full()) l.insert(l.begin(), eastl::make_pair(<span class="ch">&#39;A&#39;</span>, [](<span class="dt">uint8_t</span> v){ Serial &lt;&lt; format(<span class="st">&quot;(1:</span><span class="sc">%c</span><span class="st">)&quot;</span>, v); } ));</a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="cf">if</span> (!l.full()) l.insert(l.begin(), eastl::make_pair(<span class="ch">&#39;B&#39;</span>, [](<span class="dt">uint8_t</span> v){ Serial &lt;&lt; format(<span class="st">&quot;(2:</span><span class="sc">%c</span><span class="st">)&quot;</span>, v); } ));</a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="cf">if</span> (!l.full()) l.insert(l.begin(), eastl::make_pair(<span class="ch">&#39;C&#39;</span>, [](<span class="dt">uint8_t</span> v){ Serial &lt;&lt; format(<span class="st">&quot;(3:</span><span class="sc">%c</span><span class="st">)&quot;</span>, v); } ));</a>
<a class="sourceLine" id="cb10-15" title="15">    <span class="cf">if</span> (!l.full()) l.insert(l.begin(), eastl::make_pair(<span class="ch">&#39;D&#39;</span>, [](<span class="dt">uint8_t</span> v){ Serial &lt;&lt; format(<span class="st">&quot;(4:</span><span class="sc">%c</span><span class="st">)&quot;</span>, v); } )); <span class="co">// fails</span></a>
<a class="sourceLine" id="cb10-16" title="16">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;init: &quot;</span>; <span class="cf">for</span>(<span class="kw">auto</span> &amp;x: l) x.second(x.first);</a>
<a class="sourceLine" id="cb10-17" title="17">    <span class="co">// find &amp; erase</span></a>
<a class="sourceLine" id="cb10-18" title="18">    <span class="kw">auto</span> p = eastl::find_if(l.begin(), l.end(), [](tdata&amp; x) { <span class="cf">return</span> (x.first == <span class="ch">&#39;B&#39;</span>); } );</a>
<a class="sourceLine" id="cb10-19" title="19">    <span class="cf">if</span> (p != l.end()) l.erase(p);</a>
<a class="sourceLine" id="cb10-20" title="20">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;find&amp;erase: &quot;</span>; <span class="cf">for</span>(<span class="kw">auto</span> &amp;x: l) x.second(x.first);</a>
<a class="sourceLine" id="cb10-21" title="21">    <span class="co">// append</span></a>
<a class="sourceLine" id="cb10-22" title="22">    <span class="cf">if</span> (!l.full()) l.insert(l.end(), eastl::make_pair(<span class="ch">&#39;D&#39;</span>, [](<span class="dt">uint8_t</span> v){ Serial &lt;&lt; format(<span class="st">&quot;(4:</span><span class="sc">%c</span><span class="st">)&quot;</span>, v); } ));</a>
<a class="sourceLine" id="cb10-23" title="23">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;append: &quot;</span>; <span class="cf">for</span>(<span class="kw">auto</span> &amp;x: l) x.second(x.first);</a>
<a class="sourceLine" id="cb10-24" title="24">    <span class="co">// sort</span></a>
<a class="sourceLine" id="cb10-25" title="25">    eastl::sort(l.begin(), l.end(), eastl::less&lt;tlst::<span class="dt">value_type</span>&gt;());</a>
<a class="sourceLine" id="cb10-26" title="26">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;sort:&quot;</span>; <span class="cf">for</span>(<span class="kw">auto</span> &amp;x: l) x.second(x.first);</a>
<a class="sourceLine" id="cb10-27" title="27">    <span class="co">// sort reverse</span></a>
<a class="sourceLine" id="cb10-28" title="28">    eastl::sort(l.begin(), l.end(), eastl::greater&lt;tlst::<span class="dt">value_type</span>&gt;());</a>
<a class="sourceLine" id="cb10-29" title="29">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;sort(rev):&quot;</span>; <span class="cf">for</span>(<span class="kw">auto</span> &amp;x: l) x.second(x.first);</a>
<a class="sourceLine" id="cb10-30" title="30">}</a></code></pre></div>
<p><code>fixed_list</code> のテンプレート引数は３つあり、１番目が型、２番目が最大数、３番目は_false_にします。リストの操作については、一般の <code>std::list</code> に類似した <code>.insert()</code>, <code>.erase()</code> などが利用できます。</p>
<p>上記のコードでは、リストにはペア <code>eastl::pair</code> の要素を格納し、ペアの first を <code>uint8_t</code> 型の整数、second を <code>void (*)(uint8_t)</code> の関数ポインタとしています。コード中はラムダ式を直接記述しています。コード中の <code>x.second(x.first);</code> は second から得られる関数に対して first の値を与えるという意味合いになります。</p>
<p>このリストに対して <code>eastl::find_if</code> による要素の検索を行ったり、<code>bubble_sort</code>によるソートが可能です。</p>
<h3 id="intrusive_list">intrusive_list</h3>
<p>通常のリストは任意のデータ構造を要素とできますが、intrusive_list は要素に特定のデータを付与し、そのデータを用いることでデータ構造を構築します。</p>
<p>以下の例では、intruslve_list データ構造の要素となるには <code>eastl::intrusive_list_node</code> を継承したデータ要素型であることを要件とします。<code>eastl::intrusive_list_node</code>には前後の要素に対するポインタを格納できるような拡張です。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="pp">#include </span><span class="im">&lt;EASTL/fixed_vector.h&gt;</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="pp">#include </span><span class="im">&lt;EASTL/intrusive_list.h&gt;</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="pp">#include </span><span class="im">&lt;EASTL/unique_ptr.h&gt;</span></a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="co">// list element of intrusive_list.</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="kw">struct</span> IntNode : <span class="kw">public</span> eastl::intrusive_list_node { </a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="dt">int</span> mX;</a>
<a class="sourceLine" id="cb11-9" title="9">    IntNode(<span class="dt">int</span> x = <span class="dv">0</span>) : mX(x) { }</a>
<a class="sourceLine" id="cb11-10" title="10">};</a>
<a class="sourceLine" id="cb11-11" title="11"><span class="kw">inline</span> <span class="dt">bool</span> <span class="kw">operator</span>&gt;(<span class="at">const</span> IntNode&amp; a, <span class="at">const</span> IntNode&amp; b) { <span class="cf">return</span> a.mX &gt; b.mX; } <span class="co">// for sort</span></a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13"><span class="kw">using</span> tpool = eastl::fixed_vector&lt;IntNode, <span class="dv">16</span>, <span class="kw">false</span>&gt;;</a>
<a class="sourceLine" id="cb11-14" title="14"><span class="kw">using</span> tlst = eastl::intrusive_list&lt;IntNode&gt;;</a>
<a class="sourceLine" id="cb11-15" title="15"></a>
<a class="sourceLine" id="cb11-16" title="16">tpool pool; <span class="co">// instance pool.</span></a>
<a class="sourceLine" id="cb11-17" title="17">tlst l; <span class="co">// list object</span></a>
<a class="sourceLine" id="cb11-18" title="18"></a>
<a class="sourceLine" id="cb11-19" title="19"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb11-20" title="20">    mwx::pnew(pool); <span class="co">// prepare isntances</span></a>
<a class="sourceLine" id="cb11-21" title="21">    mwx::pnew(l); <span class="co">// initialize (call constructor)</span></a>
<a class="sourceLine" id="cb11-22" title="22"></a>
<a class="sourceLine" id="cb11-23" title="23">    pool.resize(<span class="dv">5</span>); <span class="co">// create 4 instances into pool</span></a>
<a class="sourceLine" id="cb11-24" title="24"></a>
<a class="sourceLine" id="cb11-25" title="25">    <span class="co">// insert an IntNode element into List.</span></a>
<a class="sourceLine" id="cb11-26" title="26">    <span class="dt">int</span> i = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb11-27" title="27">    pool[i].mX = <span class="dv">5</span>; l.push_front(pool[i]); i++;</a>
<a class="sourceLine" id="cb11-28" title="28">    pool[i].mX = <span class="dv">1</span>; l.push_front(pool[i]); i++;</a>
<a class="sourceLine" id="cb11-29" title="29">    pool[i].mX = <span class="dv">2</span>; l.push_front(pool[i]); i++;</a>
<a class="sourceLine" id="cb11-30" title="30">    pool[i].mX = <span class="dv">4</span>; l.push_front(pool[i]); i++;</a>
<a class="sourceLine" id="cb11-31" title="31">    pool[i].mX = <span class="dv">3</span>; l.push_front(pool[i]); i++;</a>
<a class="sourceLine" id="cb11-32" title="32">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;init: &quot;</span>;</a>
<a class="sourceLine" id="cb11-33" title="33">    <span class="cf">for</span>(<span class="kw">auto</span>&amp; x : l) { Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x.mX); }</a>
<a class="sourceLine" id="cb11-34" title="34"></a>
<a class="sourceLine" id="cb11-35" title="35">    l.remove(pool[<span class="dv">2</span>]);</a>
<a class="sourceLine" id="cb11-36" title="36">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;remove: &quot;</span>;</a>
<a class="sourceLine" id="cb11-37" title="37">    <span class="cf">for</span>(<span class="kw">auto</span>&amp; x : l) { Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x.mX); }</a>
<a class="sourceLine" id="cb11-38" title="38"></a>
<a class="sourceLine" id="cb11-39" title="39">    l.sort(eastl::greater&lt;tlst::<span class="dt">value_type</span>&gt;());</a>
<a class="sourceLine" id="cb11-40" title="40">    Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;sort: &quot;</span>;</a>
<a class="sourceLine" id="cb11-41" title="41">    <span class="cf">for</span>(<span class="kw">auto</span>&amp; x : l) { Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x.mX); }</a>
<a class="sourceLine" id="cb11-42" title="42">}</a></code></pre></div>
<p>この例で <code>eastl::fixed_vector&lt;&gt;</code> が使用されているのは、<code>IntNode</code> の要素を必要数確保する目的で、<code>fixed_vector</code>が必要だったわけではありません。５つの要素にテストの値を格納して intrusive_list を構築します。例では <code>l.push_pront()</code> を呼び出し要素をひとつずつリストに格納しています。実際は格納するのではなく、各要素 <code>IntNode</code> が持つポインタの繋ぎ変えです。</p>
<p>ソートの記述は <code>l.sort()</code> のようにメンバ関数の呼び出しで行います。</p>
<h3 id="ring_buffer">ring_buffer</h3>
<p>リングバッファ <code>ring_buffer</code> は、他のコンテナ（例では <code>fixed_vector</code>） との組み合わせで構築されます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="pp">#include </span><span class="im">&lt;EASTL/fixed_vector.h&gt;</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="pp">#include </span><span class="im">&lt;EASTL/bonus/ring_buffer.h&gt;</span></a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="at">const</span> <span class="dt">size_t</span> N_RING_ELE = <span class="dv">4</span>; <span class="co">// element max for RING BUFFER.</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="kw">using</span> tvec = eastl::fixed_vector&lt;<span class="dt">uint8_t</span>, N_RING_ELE + <span class="dv">1</span>, <span class="kw">false</span>&gt;; <span class="co">// One extra element is required.</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="kw">using</span> tring = eastl::ring_buffer&lt;<span class="dt">uint8_t</span>, tvec&gt;;</a>
<a class="sourceLine" id="cb12-8" title="8">tring rb;</a>
<a class="sourceLine" id="cb12-9" title="9"></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb12-11" title="11">    mwx::pnew(rb, N_RING_ELE);</a>
<a class="sourceLine" id="cb12-12" title="12"></a>
<a class="sourceLine" id="cb12-13" title="13">    rb.push_front(<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb12-14" title="14">    rb.push_front(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb12-15" title="15">    rb.push_front(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb12-16" title="16">    rb.push_front(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb12-17" title="17">    Serial &lt;&lt; crlf; <span class="cf">for</span> (<span class="kw">auto</span> x : rb) Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x);</a>
<a class="sourceLine" id="cb12-18" title="18">    rb.push_front(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb12-19" title="19">    Serial &lt;&lt; crlf; <span class="cf">for</span> (<span class="kw">auto</span> x : rb) Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x);</a>
<a class="sourceLine" id="cb12-20" title="20">    rb.push_front(<span class="dv">8</span>);</a>
<a class="sourceLine" id="cb12-21" title="21">    Serial &lt;&lt; crlf; <span class="cf">for</span> (<span class="kw">auto</span> x : rb) Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x);</a>
<a class="sourceLine" id="cb12-22" title="22">    rb.push_front(<span class="dv">9</span>);</a>
<a class="sourceLine" id="cb12-23" title="23">    Serial &lt;&lt; crlf; <span class="cf">for</span> (<span class="kw">auto</span> x : rb) Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x);</a>
<a class="sourceLine" id="cb12-24" title="24"></a>
<a class="sourceLine" id="cb12-25" title="25">    Serial &lt;&lt; crlf &lt;&lt; format(<span class="st">&quot;back=</span><span class="sc">%d</span><span class="st">&quot;</span>, rb.back()) &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb12-26" title="26">    rb.pop_back();</a>
<a class="sourceLine" id="cb12-27" title="27">    <span class="cf">for</span> (<span class="kw">auto</span> x : rb) Serial &lt;&lt; format(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>, x);</a>
<a class="sourceLine" id="cb12-28" title="28">}</a></code></pre></div>
<p><code>ring_buffer</code> の定義は、要素型とそのコンテナ型の組み合わせです。要素型は余分に一つ要素を持たせておきます。</p>
<p>上記の例では <code>.push_front()</code> で先頭に要素を挿入します。オーバーフローすると末尾は消えてしまいます。 <code>.back()</code>により一番古い要素を取り出します。<code>pop_back()</code>で一番古い要素を削除します。</p>
<h3 id="intrusive_hash_map">intrusive_hash_map</h3>
<p>マップ構造は、キーと値をもつデータ構造で、キー値により効率よく要素を抽出できるように設計されたデータ構造です。 intrusive_hash_map は intrusive 構造とハッシュ値を用いて実装しています。いくばくか定義は煩雑ですが、メモリ消費量は抑制できます。</p>
<p>intrusive_list と同様独自の要素型 <code>IntNode</code> を <code>eastl::intrusive_hash_node_key&lt;要素型&gt;</code> を継承した形で定義する必要があります。またハッシュを用いるためハッシュ最大値 (<code>N_BUCKET_CT</code>) を定めておく必要があります。この値は、想定される格納要素数に応じて適切に素数の値を設定します。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="pp">#include </span><span class="im">&lt;EASTL/internal/intrusive_hashtable.h&gt;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="pp">#include </span><span class="im">&lt;EASTL/intrusive_hash_map.h&gt;</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="at">static</span> <span class="at">const</span> <span class="dt">unsigned</span> N_BUCKET_CT = <span class="dv">7</span>;</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="co">// intrusive element type</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="kw">struct</span> IntNode : <span class="kw">public</span> eastl::intrusive_hash_node_key&lt;<span class="dt">uint8_t</span>&gt; {</a>
<a class="sourceLine" id="cb13-9" title="9">    <span class="kw">using</span> SUP = intrusive_hash_node_key;</a>
<a class="sourceLine" id="cb13-10" title="10">    <span class="dt">void</span> (*<span class="va">m_func</span>)(); <span class="co">// member variable is func pointer.</span></a>
<a class="sourceLine" id="cb13-11" title="11">    IntNode(<span class="dt">uint8_t</span> key = <span class="dv">0</span>) { SUP::mKey = key; } <span class="co">// key will be passed by the constructor.</span></a>
<a class="sourceLine" id="cb13-12" title="12">};</a>
<a class="sourceLine" id="cb13-13" title="13"></a>
<a class="sourceLine" id="cb13-14" title="14"><span class="co">// intrusive map type</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="kw">using</span> tmap = eastl::intrusive_hash_map&lt;<span class="dt">uint8_t</span>, IntNode, N_BUCKET_CT&gt;;</a>
<a class="sourceLine" id="cb13-16" title="16"></a>
<a class="sourceLine" id="cb13-17" title="17">tmap mp;</a>
<a class="sourceLine" id="cb13-18" title="18">IntNode nd_a, nd_b, nd_c, nd_d;</a>
<a class="sourceLine" id="cb13-19" title="19"></a>
<a class="sourceLine" id="cb13-20" title="20"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb13-21" title="21">    mwx::pnew(mp); <span class="co">// initialize (call constructor)</span></a>
<a class="sourceLine" id="cb13-22" title="22"></a>
<a class="sourceLine" id="cb13-23" title="23">    mwx::pnew(nd_a, <span class="ch">&#39;A&#39;</span>)-&gt;<span class="va">m_func</span> = []() { Serial &lt;&lt; <span class="st">&quot;FuncA&quot;</span>; };</a>
<a class="sourceLine" id="cb13-24" title="24">    mwx::pnew(nd_b, <span class="ch">&#39;B&#39;</span>)-&gt;<span class="va">m_func</span> = []() { Serial &lt;&lt; <span class="st">&quot;FuncB&quot;</span>; };</a>
<a class="sourceLine" id="cb13-25" title="25">    mwx::pnew(nd_c, <span class="ch">&#39;C&#39;</span>)-&gt;<span class="va">m_func</span> = []() { Serial &lt;&lt; <span class="st">&quot;FuncC&quot;</span>; };</a>
<a class="sourceLine" id="cb13-26" title="26">    mwx::pnew(nd_d, <span class="ch">&#39;D&#39;</span>)-&gt;<span class="va">m_func</span> = []() { Serial &lt;&lt; <span class="st">&quot;FuncD&quot;</span>; };</a>
<a class="sourceLine" id="cb13-27" title="27"></a>
<a class="sourceLine" id="cb13-28" title="28">    mp.insert(nd_a);</a>
<a class="sourceLine" id="cb13-29" title="29">    mp.insert(nd_b);</a>
<a class="sourceLine" id="cb13-30" title="30">    mp.insert(nd_c);</a>
<a class="sourceLine" id="cb13-31" title="31">    mp.insert(nd_d);</a>
<a class="sourceLine" id="cb13-32" title="32">}</a>
<a class="sourceLine" id="cb13-33" title="33"></a>
<a class="sourceLine" id="cb13-34" title="34"><span class="dt">void</span> loop() {</a>
<a class="sourceLine" id="cb13-35" title="35">    <span class="dt">int</span> c = Serial.read();</a>
<a class="sourceLine" id="cb13-36" title="36">    <span class="cf">if</span>(c != -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb13-37" title="37">        Serial &lt;&lt; crlf &lt;&lt; <span class="ch">&#39;[&#39;</span> &lt;&lt; <span class="dt">uint8_t</span>(c) &lt;&lt; <span class="ch">&#39;]&#39;</span>;</a>
<a class="sourceLine" id="cb13-38" title="38">        <span class="kw">auto</span>&amp;&amp; it = mp.find(<span class="dt">uint8_t</span>(c));</a>
<a class="sourceLine" id="cb13-39" title="39">        <span class="cf">if</span> (it != mp.end()) it-&gt;<span class="va">m_func</span>();</a>
<a class="sourceLine" id="cb13-40" title="40">    }</a>
<a class="sourceLine" id="cb13-41" title="41">}</a></code></pre></div>
<p>上記の例は、マップのキーを <code>uint8_t</code> 型の１文字とし、マップの値部分を関数ポインタとします。<code>loop()</code>ではキーの入力に応じた関数を実行するといった処理を行います。</p>
<p>最初に、グローバルオブジェクトとしてテーブルと要素を定義したため、<code>setup()</code>中で <code>mwx::pnew()</code> を呼び出すことでデータ要素(<code>nd_a, nd_b, nd_c, nd_d</code>)の初期化、ハッシュマップの初期化 (<code>mp</code>) を行っておきます。<code>mwx::pnew()</code> の戻り値は、構築したオブジェクトへのポインタですので、初期化後直接メンバ変数に値（ラムダ式）を書き込んでいます。</p>
<p>要素(<code>nd_a, nd_b, nd_c, nd_d</code>)の初期と値の設定が終わったら <code>mp.insert(nd_a)</code> のようにマップに要素を挿入していきます。</p>
<p><code>loop()</code>ではシリアルから文字を入力するたびに、ハッシュマップの検索を行います。検索は <code>mp.find()</code> メソッドを呼び出し、戻り値はイテレータで、検索失敗時は <code>mp.end()</code> が戻ります。検索が成功したら <code>(*it)</code> により検索出来た要素を参照できます。</p>
<div class="info">
<p><code>intrusive_hash_multimap</code> は値の重複を許容するマルチマップです。利用方法はハッシュマップとほぼ同じですが、検索時に <code>.equal_range()</code> 用い、イテレータのペアとして取り扱う点が違います。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">using</span> tmap = eastl::intrusive_hash_multimap&lt;<span class="dt">uint8_t</span>, IntNode, N_BUCKET_CT&gt;;</a>
<a class="sourceLine" id="cb14-2" title="2">...</a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="co">// find emelents by key `c&#39;</span></a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="kw">auto</span> ip = mp.equal_range(<span class="dt">uint8_t</span>(c));</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="cf">for</span>(<span class="kw">auto</span>&amp;&amp; it = ip.first; it != ip.second; it++) {</a>
<a class="sourceLine" id="cb14-6" title="6">        it-&gt;<span class="va">m_func</span>();</a>
<a class="sourceLine" id="cb14-7" title="7">    }</a></code></pre></div>
</div>
</body>
</html>
