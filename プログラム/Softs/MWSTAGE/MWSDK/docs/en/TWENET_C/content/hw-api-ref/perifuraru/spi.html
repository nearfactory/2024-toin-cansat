<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#spi">SPI</a><ul>
<li><a href="#functions">functions</a><ul>
<li><a href="#vahi_spiconfigure">vAHI_SpiConfigure()</a></li>
<li><a href="#vahi_spiselect">vAHI_SpiSelect()</a></li>
<li><a href="#vahi_spistarttransfer">vAHI_SpiStartTransfer()</a></li>
<li><a href="#bahi_spipollbusy">bAHI_SpiPollBusy()</a></li>
<li><a href="#u32ahi_spireadtransfer32">u32AHI_SpiReadTransfer32()</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="spi">SPI</h1>
<p>The SPI bus is used for reading and writing sensors, memory devices, etc. Although it uses more pins than I2C, it is often used for devices that require high-speed transfer.</p>
<div class="info">
<p>Please refer to the Samp_SPI sample.</p>
</div>
<p>When using the SPI bus, only enough SPI select pins are allocated for the required device. The pins are allocated in order, starting with the SEISEL0 pin.</p>
<p>The following are some examples of initialization and read/write operations; SPI also allows simultaneous write and read operations.</p>
<p>A common example when acquiring data from a sensor is the procedure of sending a command followed by getting the result.</p>
<ol type="1">
<li>Initialize SPI (start using device)</li>
<li>Enable select pin for SPI</li>
<li>SPI Transfer 1 (8 bits), intended for transmission.</li>
<li>SPI transfer 2 (16 bits), intended for reception.</li>
</ol>
<div class="danger">
<p>You should always wait for polling (<code>while(bAHI_SpiPollBusy());</code>) on each transfer.</p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#define SLAVE_ENABLE2       (1)         </span><span class="co">//  Using DIO19 and DIO0</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#define CS_DIO19            (0x01)      </span><span class="co">//  Use the one connected to SPISEL0:DIO19</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">#define CS_DIO0             (0x02)      </span><span class="co">//  SPISEL1: Use the one connected to DIO0</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">    ...</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="co">// SPI の初期化</span></a>
<a class="sourceLine" id="cb1-7" title="7">    vAHI_SpiConfigure(SLAVE_ENABLE2, <span class="co">// Use two SPISEL0,1</span></a>
<a class="sourceLine" id="cb1-8" title="8">                      E_AHI_SPIM_MSB_FIRST,</a>
<a class="sourceLine" id="cb1-9" title="9">                      TRUE,</a>
<a class="sourceLine" id="cb1-10" title="10">                      TRUE,</a>
<a class="sourceLine" id="cb1-11" title="11">                      <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb1-12" title="12">                      E_AHI_SPIM_INT_DISABLE,</a>
<a class="sourceLine" id="cb1-13" title="13">                      E_AHI_SPIM_AUTOSLAVE_DSABL);</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15">    ...</a>
<a class="sourceLine" id="cb1-16" title="16">    <span class="co">// Transfer 1（8bit write out)</span></a>
<a class="sourceLine" id="cb1-17" title="17">    vAHI_SpiSelect(CS_DIO0); <span class="co">// Enable SPISEL1</span></a>
<a class="sourceLine" id="cb1-18" title="18">    vAHI_SpiStartTransfer(</a>
<a class="sourceLine" id="cb1-19" title="19">                    <span class="dv">7</span>, <span class="co">// 7+1=8 bit transfer</span></a>
<a class="sourceLine" id="cb1-20" title="20">                    <span class="bn">0x00000012</span><span class="bu">L</span> ); <span class="co">// sends 0x12</span></a>
<a class="sourceLine" id="cb1-21" title="21">    <span class="cf">while</span>(bAHI_SpiPollBusy()); <span class="co">// Waiting for read/write by polling</span></a>
<a class="sourceLine" id="cb1-22" title="22">    <span class="co">//uint8 u8val = u8AHI_SpiReadTransfer8();</span></a>
<a class="sourceLine" id="cb1-23" title="23">        <span class="co">// SPIMISO input data can be read.</span></a>
<a class="sourceLine" id="cb1-24" title="24">        <span class="co">// In this example, u8val is not used.</span></a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="co">// Give it some time if necessary.</span></a>
<a class="sourceLine" id="cb1-27" title="27">    vWait(<span class="dv">100</span>);</a>
<a class="sourceLine" id="cb1-28" title="28">    </a>
<a class="sourceLine" id="cb1-29" title="29">    <span class="co">//　Transfer 2 (16-bit read)</span></a>
<a class="sourceLine" id="cb1-30" title="30">    vAHI_SpiStartTransfer(</a>
<a class="sourceLine" id="cb1-31" title="31">                    <span class="dv">15</span>, <span class="co">// transfer 15+1=16 bit</span></a>
<a class="sourceLine" id="cb1-32" title="32">                    <span class="bn">0x00000000</span><span class="bu">L</span> ); <span class="co">// dummy send data</span></a>
<a class="sourceLine" id="cb1-33" title="33">    <span class="cf">while</span>(bAHI_SpiPollBusy()); <span class="co">// Waiting for read/write by polling</span></a>
<a class="sourceLine" id="cb1-34" title="34">    uint16 u16val = u16AHI_SpiReadTransfer16();</a>
<a class="sourceLine" id="cb1-35" title="35">        <span class="co">// The read 16bit data is stored to u16val.</span></a>
<a class="sourceLine" id="cb1-36" title="36"></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="co">// release the SPISEL</span></a>
<a class="sourceLine" id="cb1-38" title="38">    vAHI_SpiStop();</a>
<a class="sourceLine" id="cb1-39" title="39"></a>
<a class="sourceLine" id="cb1-40" title="40">    ...</a>
<a class="sourceLine" id="cb1-41" title="41">    <span class="co">// disable the SPI device.</span></a>
<a class="sourceLine" id="cb1-42" title="42">    vAHI_SpiDisable();</a></code></pre></div>
<h2 id="functions">functions</h2>
<h3 id="vahi_spiconfigure">vAHI_SpiConfigure()</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> vAHI_SpiConfigure(</a>
<a class="sourceLine" id="cb2-2" title="2">    uint8 u8SlaveEnable,</a>
<a class="sourceLine" id="cb2-3" title="3">    bool_t bLsbFirst,</a>
<a class="sourceLine" id="cb2-4" title="4">    bool_t bPolarity,</a>
<a class="sourceLine" id="cb2-5" title="5">    bool_t bPhase,</a>
<a class="sourceLine" id="cb2-6" title="6">    uint8 u8ClockDivider,</a>
<a class="sourceLine" id="cb2-7" title="7">    bool_t bInterruptEnable,</a>
<a class="sourceLine" id="cb2-8" title="8">    bool_t bAutoSlaveSelect);</a></code></pre></div>
<p>This function initializes the SPI device and makes it available, and calls <code>vAHI_SpiDisable()</code> to release it.</p>
<div class="warning">
<p>At least one select pin, SPISEL0, is assigned exclusively to SPI. In other words, when using SPI, SPISEL0 (DIO19) cannot be used for any other purpose.</p>
</div>
<table>
<colgroup>
<col style="width: 10%"></col>
<col style="width: 90%"></col>
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Remark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>u8SalveEnable</code></td>
<td>Specifies the chip select pin to be enabled. 0 specifies SPISEL0 to be reserved, 1 specifies SPISEL0,1 to be reserved, and 2 specifies SPISEL0,1,2 to be reserved.</td>
</tr>
<tr class="even">
<td><code>bLsbFirst</code></td>
<td>If <code>TRUE</code>, the data starts from LSB (lower bit).</td>
</tr>
<tr class="odd">
<td><code>bPolarity</code></td>
<td>If <code>TRUE</code>, reverse the clock.</td>
</tr>
<tr class="even">
<td><code>bPhase</code></td>
<td>If <code>TRUE</code>, use the falling edge.</td>
</tr>
<tr class="odd">
<td><code>u8ClockDiviser</code></td>
<td>Specifies the clock frequency, 0…63, where 0 means 16MHz drive, and the rest are divided by <code>2*u8ClockDiviser</code>.</td>
</tr>
<tr class="even">
<td><code>bInterruptEnable</code></td>
<td>Generates an interrupt at the end of SPI transfer. (It is not used in the samples.)</td>
</tr>
<tr class="odd">
<td><code>bAutoSlaveSelect</code></td>
<td>If <code>TRUE</code>, control of the select pin is set to automatic control only during SPI transfer. If <code>FALSE</code>, it is set at the timing of calling <code>vAHI_SpiSelect()</code>.</td>
</tr>
</tbody>
</table>
<div class="info">
<p>The values of <code>bLsbFirst</code>, <code>bPolarity</code>, <code>bPhase</code>, and <code>u8ClockDiviser</code> should be determined from the datasheet of the device to be connected.</p>
</div>
<h4 id="relationship-between-spi-mode-and-bpolarity-bphase.">Relationship between SPI Mode and bPolarity, bPhase.</h4>
<table>
<thead>
<tr class="header">
<th>SPI Mode</th>
<th><code>bPolarity</code></th>
<th><code>bPhase</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>FALSE</code></td>
<td><code>FALSE</code></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>FALSE</code></td>
<td><code>TRUE</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>TRUE</code></td>
<td><code>FALSE</code></td>
</tr>
<tr class="even">
<td>3</td>
<td><code>TRUE</code></td>
<td><code>TRUE</code></td>
</tr>
</tbody>
</table>
<h3 id="vahi_spiselect">vAHI_SpiSelect()</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> vAHI_SpiSelect(uint8 u8SlaveMask);</a></code></pre></div>
<p>Activate select pins.</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Remark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>u8SalveMask</code></td>
<td><code>1</code>: SPISEL0, <code>2</code>:SPISEL1, <code>4</code>:SPISEL3, <code>0</code>: cancel select.</td>
</tr>
</tbody>
</table>
<div class="info">
<p><code>vAHI_SpiStop()</code> and <code>vAHI_SpiSelect(0)</code> are the same call.</p>
</div>
<h3 id="vahi_spistarttransfer">vAHI_SpiStartTransfer()</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> vAHI_SpiStartTransfer(uint8 u8CharLen, uint32 u32Out);</a></code></pre></div>
<p>Start SPI transfer. The transfer starts immediately after this function is called, but the control is returned without waiting for the transfer to finish. It waits for the end of transfer by <code>bAHI_SpiPollBusy()</code> described below.</p>
<table>
<colgroup>
<col style="width: 5%"></col>
<col style="width: 94%"></col>
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Remark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>u8CharLen</code></td>
<td>Specifies the transfer length. 0…31 can be specified, and the specified number + 1 bit is transferred. For example, for a 16-bit transfer, specify 15.</td>
</tr>
<tr class="even">
<td><code>u32Out</code></td>
<td>The bit sequence to be output. For transfers of less than 32 bits, the data is right-justified to the LSB side. (In the case of 8-bit data, the data is stored in bit0 to bit7.)</td>
</tr>
</tbody>
</table>
<h3 id="bahi_spipollbusy">bAHI_SpiPollBusy()</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1">bool_t bAHI_SpiPollBusy(<span class="dt">void</span>);</a></code></pre></div>
<p>Waiting for polling of SPI transfer, while TRUE means SPI transfer is in progress.</p>
<h3 id="u32ahi_spireadtransfer32">u32AHI_SpiReadTransfer32()</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"> uint32 u32AHI_SpiReadTransfer32(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb6-2" title="2"> uint16 u16AHI_SpiReadTransfer16(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb6-3" title="3"> uint8 u8AHI_SpiReadTransfer8(<span class="dt">void</span>);</a></code></pre></div>
<p>Called after the SPI transfer is completed, this function reads the received data (SPIMISO) at the time of transfer. The read data is right justified to the LSB side.</p>
</body>
</html>
