<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mono Wireless Inc." />
  <title>The design policy</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">The design policy</h1>
<p class="author">Mono Wireless Inc.</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#the-design-policy">The design policy</a><ul>
<li><a href="#design-policy">Design Policy</a></li>
<li><a href="#about-the-c-compiler">About the C++ Compiler</a></li>
<li><a href="#c-limitations">C++ limitations</a></li>
<li><a href="#design-memo">Design Memo</a><ul>
<li><a href="#current-implementation">Current implementation</a></li>
<li><a href="#namespace">namespace</a></li>
<li><a href="#crtpcuriously-recursive-template-patterns.">CRTP(Curiously recursive template patterns.) </a></li>
<li><a href="#virtualization-with-crtp">Virtualization with CRTP</a></li>
<li><a href="#new-new-operator">new, new[] operator</a></li>
<li><a href="#container-class">Container class</a></li>
<li><a href="#variable-parameter">variable parameter</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#implementing-interrupt-event-and-state-handlers">Implementing interrupt, event, and state handlers</a></li>
<li><a href="#stream-class">Stream class</a></li>
<li><a href="#worker-object-for-wire-spi">Worker object for Wire, SPI</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="the-design-policy">The design policy</h1>
<p>This section describes the specifications, limitations, notes in this document, and design memos for the C++ language used in the MWX library.</p>
<div class="info">
<p>This page is intended for use in situations where you need to refer to the library resource code to understand how the library works or to modify it. It assumes a higher level of knowledge of the C++ language compared to using the library.</p>
</div>
<h2 id="design-policy">Design Policy</h2>
<ul>
<li>The application loop description is intended to be similar to the commonly used API system, but the implementation should be tailored to the characteristics of TWELITE.</li>
<li>TWENET is an event-driven code description, and it should be classed so that it can be handled. The above classifications will encapsulate the behavior of the application.</li>
<li>Event-driven and loop descriptions should be able to coexist.</li>
<li>Simplify procedures by classifying typical peripherals. Make them accessible by loop descriptions whenever possible.</li>
<li>Simplify the procedures for using the boards we sell, such as MONOSTICK/PAL, by creating classes. (For example, to automate the use of an external watchdog timer.</li>
<li>Application classes and board classes should be made available through a unified procedure, introducing the idea of polymorphism. (For example, to load application classes with several behaviors at startup, and to avoid defining the connection code of the TWENET C library each time).</li>
<li>There are no restrictions on the use of C++ functionality. For example, it provides a means to simplify typical procedures such as packet construction and decomposition, which are complicated in handling wireless packets.</li>
<li>The operator <code>-&gt;</code> should be avoided as much as possible, and the API should be based on reference types in principle.</li>
</ul>
<div class="info">
<p>As we are working on the implementation in a limited time, the design does not cover all the details, but if you have any questions about the design or implementation, please contact our support.</p>
</div>
<h2 id="about-the-c-compiler">About the C++ Compiler</h2>
<h4 id="version">Version</h4>
<p>gcc version 4.7.4</p>
<h4 id="c-standard">C++ standard</h4>
<p>C++11 (For compiler support status, please refer to the general information.)</p>
<ul>
<li><a target=_blank href="https://gcc.gnu.org/gcc-4.7/cxx0x_status.html">https://gcc.gnu.org/gcc-4.7/cxx0x_status.html</a> </li>
<li><a target=_blank href="https://cpprefjp.github.io/implementation-status.html">https://cpprefjp.github.io/implementation-status.html</a> </li>
</ul>
<h2 id="c-limitations">C++ limitations</h2>
<p>※ This is a description of what we know.</p>
<ul>
<li>You can allocate memory with the new and new[] operators, but you cannot destroy the allocated memory; most C++ libraries that allocate memory dynamically are virtually unusable. It is used for objects that are created only once and not destroyed after that.</li>
<li>The constructor of the global object is not called.<br />
Note: If necessary, you can initialize the constructor call by using the initialization function (<code>setup()</code>) as shown in (<code>new ((void*)&amp;obj_global) class_foo();</code>).</li>
<li>Exception cannot be used.</li>
<li>Unable to use virtual function.</li>
</ul>
<h2 id="design-memo">Design Memo</h2>
<p>This section contains information that will help you understand the code when referring to the MWX library code.</p>
<h3 id="current-implementation">Current implementation</h3>
<p>Due to the limited time available for implementation, some of the details may not be sufficiently developed. For example, const is not fully taken into account in many classes.</p>
<h3 id="namespace">namespace</h3>
<p>We have the following policy for namespaces.</p>
<ul>
<li>In principle, definitions are placed in a common namespace mwx.</li>
<li>We want to be able to use namespaces without identifiers, but we want to require identifiers for some definitions.</li>
<li>Class names should be relatively long, and those used by users should be defined as aliases.</li>
</ul>
<p>Classes, Functions, and constants are defined within the namespace of mwx names (more precisely, mwx::L1 enclosed in inline namespace L1), with a few exceptions. inline namespace is specified so that definitions that require the specification of mwx:: can coexist with those that do not. The reason why inline namespace is specified is to allow definitions that require the specification of mwx:: to coexist with those that do not.</p>
<p>Most of the definitions do not require namespace names to be specified by using namespace. These specifications are made in <code>using_mwx_def.hpp</code> in the library.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// at some header file.</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">namespace</span> mwx {</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">inline</span> <span class="kw">namespace</span> L1 {</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="kw">class</span> foobar {</a>
<a class="sourceLine" id="cb1-5" title="5">      <span class="co">// class definition...</span></a>
<a class="sourceLine" id="cb1-6" title="6">    };</a>
<a class="sourceLine" id="cb1-7" title="7">  }</a>
<a class="sourceLine" id="cb1-8" title="8">}</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">// at using_mwx_def.hpp</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">using</span> <span class="kw">namespace</span> mwx::L1; <span class="co">// Definitions in mwx::L1 can be accessed without mwx::.</span></a>
<a class="sourceLine" id="cb1-12" title="12">                         <span class="co">// But mwx::L2 needs mwx::.</span></a></code></pre></div>
<p>Exceptionally, relatively short names can be specified as <code>mwx::crlf</code>, <code>mwx::flush</code>. These are placed in the inline namespace mwx::L2; using namespace mwx::L2; will allow them to be used without specifying the namespace name.</p>
<p>Also, some class names have a using specification.</p>
<p>The <code>std::make_pair</code> used in the MWX library is specified using.</p>
<h3 id="crtpcuriously-recursive-template-patterns.">CRTP(Curiously recursive template patterns.) </h3>
<p>Since virtual functions (virtual) and run-time type information (RTTI) are not available, and even if they were available, they would be difficult to perform, <a target=_blank href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP (Curiously recurring template pattern)</a>is used as an alternative design method. CRTP is a template pattern for calling methods of a child class from the parent class from which it is inherited.</p>
<p>The following example shows how to implement an interface called <code>interface()</code> in a <code>Derived</code> class that inherits from <code>Base</code>, and calls the <code>Derived::print()</code> method from <code>Base</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">class</span> Base {</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="dt">void</span> intrface() {</a>
<a class="sourceLine" id="cb2-5" title="5">    T* derived = <span class="kw">static_cast</span>&lt;T*&gt;(<span class="kw">this</span>);</a>
<a class="sourceLine" id="cb2-6" title="6">    derived-&gt;prt();</a>
<a class="sourceLine" id="cb2-7" title="7">  }</a>
<a class="sourceLine" id="cb2-8" title="8">};</a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="kw">class</span> Derived : <span class="kw">public</span> <span class="kw">class</span> Base&lt;Derived&gt; {</a>
<a class="sourceLine" id="cb2-11" title="11">  <span class="dt">void</span> prt() {</a>
<a class="sourceLine" id="cb2-12" title="12">     <span class="co">// print message here!</span></a>
<a class="sourceLine" id="cb2-13" title="13">     my_print(<span class="st">&quot;foo&quot;</span>);</a>
<a class="sourceLine" id="cb2-14" title="14">  }</a>
<a class="sourceLine" id="cb2-15" title="15">}</a></code></pre></div>
<p>The following are the main classes used in the MWX library.</p>
<ul>
<li>Basic parts of event processing<code>mwx::appdefs_crtp</code></li>
<li>state machine <code>public mwx::processev_crtp</code></li>
<li>stream <code>mwx::stream</code></li>
</ul>
<h3 id="virtualization-with-crtp">Virtualization with CRTP</h3>
<p>In the CRTP class, the class from which it inherits is different for each instance. For this reason, it is not possible to cast it to a parent class and treat it as a member of the same family, nor is it possible to use advanced polymorphism such as virtual functions or RTTI (runtime type information).</p>
<p>The following is an example of implementing the above CRTP example with a virtual function: CRTP cannot manage instances together in the same array as in Base* b[2].</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> Base {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">virtual</span> <span class="dt">void</span> prt() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="dt">void</span> intrface() { prt(); }</a>
<a class="sourceLine" id="cb3-5" title="5">};</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="kw">class</span> Derived1 : <span class="kw">public</span> Base {</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="dt">void</span> prt() { my_print(<span class="st">&quot;foo&quot;</span>); }</a>
<a class="sourceLine" id="cb3-9" title="9">};</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="kw">class</span> Derived2 : <span class="kw">public</span> Base {</a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="dt">void</span> prt() { my_print(<span class="st">&quot;bar&quot;</span>); }</a>
<a class="sourceLine" id="cb3-13" title="13">};</a>
<a class="sourceLine" id="cb3-14" title="14"></a>
<a class="sourceLine" id="cb3-15" title="15">Derived1 d1;</a>
<a class="sourceLine" id="cb3-16" title="16">Derived2 d2;</a>
<a class="sourceLine" id="cb3-17" title="17">Base* b[<span class="dv">2</span>] = { &amp;d1, &amp;d2 };</a>
<a class="sourceLine" id="cb3-18" title="18"></a>
<a class="sourceLine" id="cb3-19" title="19"><span class="dt">void</span> tst() {</a>
<a class="sourceLine" id="cb3-20" title="20">    <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; x : b) { x-&gt;intrface(); }</a>
<a class="sourceLine" id="cb3-21" title="21">}</a></code></pre></div>
<p>The MWX library solves this problem by defining a dedicated class for storing class instances of CRTP and defining a similar interface to this class. An example code is given below.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> VBase {</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dt">void</span>* p_inst;</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="dt">void</span> (*pf_intrface)(<span class="dt">void</span>* p);</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">void</span> intrface() {</a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="cf">if</span> (p_inst != <span class="kw">nullptr</span>) {</a>
<a class="sourceLine" id="cb4-9" title="9">            pf_intrface(p_inst);</a>
<a class="sourceLine" id="cb4-10" title="10">        }</a>
<a class="sourceLine" id="cb4-11" title="11">    }</a>
<a class="sourceLine" id="cb4-12" title="12">};</a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;</a>
<a class="sourceLine" id="cb4-15" title="15"><span class="kw">class</span> Base {</a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="kw">friend</span> <span class="kw">class</span> VBase;</a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="at">static</span> <span class="dt">void</span> <span class="va">s_intrface</span>(<span class="dt">void</span>* p) {</a>
<a class="sourceLine" id="cb4-18" title="18">        T* derived = <span class="kw">static_cast</span>&lt;T*&gt;(p);</a>
<a class="sourceLine" id="cb4-19" title="19">        derived-&gt;intrface();</a>
<a class="sourceLine" id="cb4-20" title="20">    }</a>
<a class="sourceLine" id="cb4-21" title="21"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb4-22" title="22">    <span class="dt">void</span> intrface() {</a>
<a class="sourceLine" id="cb4-23" title="23">        T* derived = <span class="kw">static_cast</span>&lt;T*&gt;(<span class="kw">this</span>);</a>
<a class="sourceLine" id="cb4-24" title="24">        derived-&gt;prt();</a>
<a class="sourceLine" id="cb4-25" title="25">    }</a>
<a class="sourceLine" id="cb4-26" title="26">};</a>
<a class="sourceLine" id="cb4-27" title="27"></a>
<a class="sourceLine" id="cb4-28" title="28"><span class="kw">class</span> Derived1 : <span class="kw">public</span> Base&lt;Derived1&gt; {</a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="kw">friend</span> <span class="kw">class</span> Base&lt;Derived1&gt;;</a>
<a class="sourceLine" id="cb4-30" title="30">    <span class="dt">void</span> prt() { my_print(<span class="st">&quot;foo&quot;</span>); }</a>
<a class="sourceLine" id="cb4-31" title="31">};</a>
<a class="sourceLine" id="cb4-32" title="32"></a>
<a class="sourceLine" id="cb4-33" title="33"><span class="kw">class</span> Derived2 : <span class="kw">public</span> Base&lt;Derived2&gt; {</a>
<a class="sourceLine" id="cb4-34" title="34">    <span class="kw">friend</span> <span class="kw">class</span> Base&lt;Derived2&gt;;</a>
<a class="sourceLine" id="cb4-35" title="35">    <span class="dt">void</span> prt() { my_print(<span class="st">&quot;bar&quot;</span>); }</a>
<a class="sourceLine" id="cb4-36" title="36">};</a>
<a class="sourceLine" id="cb4-37" title="37"></a>
<a class="sourceLine" id="cb4-38" title="38">Derived1 d1;</a>
<a class="sourceLine" id="cb4-39" title="39">Derived2 d2;</a>
<a class="sourceLine" id="cb4-40" title="40"></a>
<a class="sourceLine" id="cb4-41" title="41">VBase b[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb4-42" title="42"></a>
<a class="sourceLine" id="cb4-43" title="43"><span class="dt">void</span> tst() {</a>
<a class="sourceLine" id="cb4-44" title="44">    b[<span class="dv">0</span>] = d1;</a>
<a class="sourceLine" id="cb4-45" title="45">    b[<span class="dv">1</span>] = d2;</a>
<a class="sourceLine" id="cb4-46" title="46"></a>
<a class="sourceLine" id="cb4-47" title="47">    <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; x : b) {</a>
<a class="sourceLine" id="cb4-48" title="48">        x.intrface();</a>
<a class="sourceLine" id="cb4-49" title="49">    }</a>
<a class="sourceLine" id="cb4-50" title="50">}</a></code></pre></div>
<p>The VBase class member variable p_inst stores a pointer to an object of type Base , and pf_intrface is a member function pointer to Base::s_intrface. Base::s_intrface invokes the T::intrface method by being passed an object instance of itself as an argument and static_casting it to the T type.</p>
<p>Storage in VBase is implemented here by overloading the = operator (see below for source examples).</p>
<p>In the above example, when making a call to b[0].intrface(), Base::s_intrface() will be called with reference to the VBase::pf_intrface function pointer. In addition, a call to Derived1::intrface() will be made. This part is expected to be expanded inline by the compiler.</p>
<p>It is also possible to perform a conversion from the VBase type to the original Derived1 or Derived2 through a forced cast, but there is no way to directly know the type of the pointer stored in void*. Although there is no completely safe way to do this, a unique ID (TYPE_ID) is provided for each class as shown below, and the ID is checked when the cast is executed (get() method). If the get() method is called with a different type, an error message will be displayed.</p>
<p><code>B</code>If a pointer is stored as a Base type, it may not be correctly converted to a T type (e.g., when T has multiple inheritance), so a static_assert is used to determine at compile time that the pointer is derived from a Base type by using is_base_of in &lt;type_trails&gt;.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="pp">#include </span><span class="im">&lt;type_trails&gt;</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">class</span> Derived1 : <span class="kw">public</span> Base&lt;Derived1&gt; {</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb5-5" title="5">   <span class="at">static</span> <span class="at">const</span> <span class="dt">uint8_t</span> TYPE_ID = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb5-6" title="6">}</a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="kw">class</span> Derived1 : <span class="kw">public</span> Base&lt;Derived1&gt; {</a>
<a class="sourceLine" id="cb5-9" title="9"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb5-10" title="10">   <span class="at">static</span> <span class="at">const</span> <span class="dt">uint8_t</span> TYPE_ID = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb5-11" title="11">}</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="kw">class</span> VBase {</a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="dt">uint8_t</span> type_id;</a>
<a class="sourceLine" id="cb5-15" title="15"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb5-16" title="16">    </a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;</a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="dt">void</span> <span class="kw">operator</span> = (T&amp; t) {</a>
<a class="sourceLine" id="cb5-19" title="19">        <span class="kw">static_assert</span>(<span class="bu">std::</span>is_base_of&lt;Base&lt;T&gt;, T&gt;::value == <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb5-20" title="20">                        <span class="st">&quot;is not base of Base&lt;T&gt;.&quot;</span>);</a>
<a class="sourceLine" id="cb5-21" title="21"></a>
<a class="sourceLine" id="cb5-22" title="22">        type_id = T::TYPE_ID;</a>
<a class="sourceLine" id="cb5-23" title="23">        p_inst = &amp;t;</a>
<a class="sourceLine" id="cb5-24" title="24">        pf_intrface = T::<span class="va">s_intrface</span>;</a>
<a class="sourceLine" id="cb5-25" title="25">    }</a>
<a class="sourceLine" id="cb5-26" title="26">    </a>
<a class="sourceLine" id="cb5-27" title="27">  <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;</a>
<a class="sourceLine" id="cb5-28" title="28">  T&amp; get() {</a>
<a class="sourceLine" id="cb5-29" title="29">    <span class="kw">static_assert</span>(<span class="bu">std::</span>is_base_of&lt;Base&lt;T&gt;, T&gt;::value == <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb5-30" title="30">                      <span class="st">&quot;is not base of Base&lt;T&gt;.&quot;</span>);</a>
<a class="sourceLine" id="cb5-31" title="31">            </a>
<a class="sourceLine" id="cb5-32" title="32">        <span class="cf">if</span>(T::TYPE_ID == type_id) {</a>
<a class="sourceLine" id="cb5-33" title="33">            <span class="cf">return</span> *<span class="kw">reinterpret_cast</span>&lt;T*&gt;(p_inst);</a>
<a class="sourceLine" id="cb5-34" title="34">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-35" title="35">            <span class="co">// panic code here!</span></a>
<a class="sourceLine" id="cb5-36" title="36">        }</a>
<a class="sourceLine" id="cb5-37" title="37">  }</a>
<a class="sourceLine" id="cb5-38" title="38">}</a>
<a class="sourceLine" id="cb5-39" title="39"></a>
<a class="sourceLine" id="cb5-40" title="40">Derived1 d1;</a>
<a class="sourceLine" id="cb5-41" title="41">Derived2 d2;</a>
<a class="sourceLine" id="cb5-42" title="42"></a>
<a class="sourceLine" id="cb5-43" title="43">VBase b[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb5-44" title="44"></a>
<a class="sourceLine" id="cb5-45" title="45"><span class="dt">void</span> tst() {</a>
<a class="sourceLine" id="cb5-46" title="46">    b[<span class="dv">0</span>] = d1;</a>
<a class="sourceLine" id="cb5-47" title="47">    b[<span class="dv">1</span>] = d2;</a>
<a class="sourceLine" id="cb5-48" title="48">    </a>
<a class="sourceLine" id="cb5-49" title="49">  Derived1 e1 = b[<span class="dv">0</span>].get&lt;Derived1&gt;(); <span class="co">// OK</span></a>
<a class="sourceLine" id="cb5-50" title="50">  Derived2 e2 = b[<span class="dv">1</span>].get&lt;Derived2&gt;(); <span class="co">// OK</span></a>
<a class="sourceLine" id="cb5-51" title="51">  </a>
<a class="sourceLine" id="cb5-52" title="52">  Derived2 e3 = b[<span class="dv">1</span>].get&lt;Derived1&gt;(); <span class="co">// PANIC!</span></a>
<a class="sourceLine" id="cb5-53" title="53">}</a></code></pre></div>
<h3 id="new-new-operator">new, new[] operator</h3>
<p>The microcontroller in the TWELITE module does not have enough memory nor does it have advanced memory management. However, the area from the end of the microcontroller’s memory map to the stack area is available as a heap area, which can be allocated as needed. An overview of the memory map is shown in the figure below, where APP is the RAM area allocated by the application code, HEAP is the heap area, and STACK is the stack area.</p>
<pre><code>|====APP====:==HEAP==..   :==STACK==|
0                                  32KB</code></pre>
<p>Even if it is not possible to delete, the new operator may be useful in some situations. For this reason, the new and new[] operators are defined as follows: pvHear_Alloc() is a function for allocating memory provided by the semiconductor library, and the same is true for u32HeapStart and u32HeapEnd. 0xdeadbeef is a dummy address. Please do not point out that it is strange that beef is dead.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(<span class="dt">size_t</span> size) <span class="kw">noexcept</span> {</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="cf">if</span> (u32HeapStart + size &gt; u32HeapEnd) {</a>
<a class="sourceLine" id="cb7-3" title="3">        <span class="cf">return</span> (<span class="dt">void</span>*)<span class="bn">0xdeadbeef</span>;</a>
<a class="sourceLine" id="cb7-4" title="4">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb7-5" title="5">        <span class="dt">void</span> *blk = pvHeap_Alloc(NULL, size, <span class="dv">0</span>);   </a>
<a class="sourceLine" id="cb7-6" title="6">        <span class="cf">return</span> blk;</a>
<a class="sourceLine" id="cb7-7" title="7">    }</a>
<a class="sourceLine" id="cb7-8" title="8">}</a>
<a class="sourceLine" id="cb7-9" title="9"><span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>[](<span class="dt">size_t</span> size) <span class="kw">noexcept</span> {</a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="cf">return</span> <span class="kw">operator</span> <span class="kw">new</span>(size); }</a>
<a class="sourceLine" id="cb7-11" title="11"><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* ptr) <span class="kw">noexcept</span> {}</a>
<a class="sourceLine" id="cb7-12" title="12"><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>[](<span class="dt">void</span>* ptr) <span class="kw">noexcept</span> {}</a></code></pre></div>
<p>Since exceptions cannot be used, there is no way to deal with failures. Also, if you continue to allocate without being aware of the memory capacity, there is a possibility of interference with the stack area.</p>
<div class="info">
<p>The memory allocated by the system (e.g. MAC layer) is about 2.5KB.</p>
</div>
<h3 id="container-class">Container class</h3>
<p>The MWX library does not use the container classes provided by the standard library, considering the small resources of the microcontroller and the lack of dynamic memory allocation, but defines two simple container classes. The container classes have defined iterators and begin() and end() methods, so you can use some of the range for statements and STL algorithms.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1">smplbuf&lt;<span class="dt">int16_t</span>, alloc_local&lt;<span class="dt">int16_t</span>, <span class="dv">16</span>&gt;&gt; buf;</a>
<a class="sourceLine" id="cb8-2" title="2">buf.push_back(-<span class="dv">1</span>); <span class="co">// push_back() は末尾に追加</span></a>
<a class="sourceLine" id="cb8-3" title="3">buf.push_back(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb8-4" title="4">...</a>
<a class="sourceLine" id="cb8-5" title="5">buf.push_back(<span class="dv">10</span>);</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">//範囲for文</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="cf">for</span>(<span class="kw">auto</span>&amp;&amp; x : buf) { Serial &lt;&lt; <span class="dt">int</span>(x) &lt;&lt; <span class="ch">&#39;,&#39;</span> }</a>
<a class="sourceLine" id="cb8-9" title="9"><span class="co">//アルゴリズム std::minmax</span></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">auto</span>&amp;&amp; minmax = <span class="bu">std::</span>minmax_element(buf.begin(), buf.end());</a>
<a class="sourceLine" id="cb8-11" title="11">Serial &lt;&lt; <span class="st">&quot;Min=&quot;</span> &lt;&lt; <span class="dt">int</span>(*minmax.first)</a>
<a class="sourceLine" id="cb8-12" title="12">       &lt;&lt; <span class="st">&quot;,Max=&quot;</span> &lt;&lt; <span class="dt">int</span>(*minmax.second);</a></code></pre></div>
<table>
<colgroup>
<col style="width: 4%"></col>
<col style="width: 95%"></col>
</colgroup>
<thead>
<tr class="header">
<th>Class name</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>smplbuf</code></td>
<td>It is an array class that manages the maximum area (capacity) and the usable area (size) whose size can be specified within the maximum area. This class also implements the stream interface, so data can be written using the &lt;&lt; operator.</td>
</tr>
<tr class="even">
<td><code>smplque</code></td>
<td>The FIFO queue is implemented. The size of the queue is determined by template parameters. There is also a template argument to manipulate the queue using interrupt inhibition.</td>
</tr>
</tbody>
</table>
<h4 id="section"></h4>
<h4 id="about-memory-in-container-classes">About memory in container classes</h4>
<p>In the container class, the memory allocation method is specified as a parameter of the template argument.</p>
<table>
<colgroup>
<col style="width: 6%"></col>
<col style="width: 93%"></col>
</colgroup>
<thead>
<tr class="header">
<th>Class name</th>
<th>Remark</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>alloc_attach</code></td>
<td>Specify the buffer memory that has already been allocated. This is used when you want to manage the memory area allocated for the C library, or when you want to process the same buffer area as a fragmented area.</td>
</tr>
<tr class="even">
<td><code>alloc_static</code></td>
<td>Allocate as a static array in the class. The size is determined in advance or used as an area for temporary use.</td>
</tr>
<tr class="odd">
<td><code>alloc_heap</code></td>
<td>Allocate to the heap area. Once allocated to the system heap, it cannot be discarded, but it is suitable for use in initialization to allocate an area according to application settings.</td>
</tr>
</tbody>
</table>
<h3 id="variable-parameter">variable parameter</h3>
<p>In the MWX library, variable number arguments are used for operations on byte sequences, bit sequences, and printf equivalent operations. The example below shows the process of setting 1 to the specified bit position.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="co">// packing bits with given arguments, which specifies bit position.</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">//   pack_bits(5, 0, 1) -&gt; (b100011) bit0,1,5 are set.</span></a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">// The first function of recursive extraction</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head&gt;</a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">constexpr</span> <span class="dt">uint32_t</span> pack_bits(Head head) { <span class="cf">return</span>  <span class="dv">1</span><span class="bu">UL</span> &lt;&lt; head; }</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">// Extract head and transfer the rest of the parameters to pack_bits </span></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="co">//by recursive call</span></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="kw">template</span> &lt;<span class="kw">typename</span> Head, <span class="kw">typename</span>... Tail&gt;</a>
<a class="sourceLine" id="cb9-11" title="11"><span class="kw">constexpr</span> <span class="dt">uint32_t</span> pack_bits(Head head, Tail&amp;&amp;... tail) {</a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="cf">return</span> (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; head) | pack_bits(<span class="bu">std::</span>forward&lt;Tail&gt;(tail)...);</a>
<a class="sourceLine" id="cb9-13" title="13">}</a>
<a class="sourceLine" id="cb9-14" title="14"></a>
<a class="sourceLine" id="cb9-15" title="15"><span class="co">// コンパAfter ILL, the following two will have the same result.</span></a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">constexpr</span> <span class="dt">uint32_t</span> b1 = pack_bits(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">8</span>);</a>
<a class="sourceLine" id="cb9-17" title="17"><span class="co">// b1 and b2 are the same! </span></a>
<a class="sourceLine" id="cb9-18" title="18"><span class="at">const</span> <span class="dt">uint32_t</span> b2 = (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">1</span>)|(<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">4</span>)|(<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">0</span>)|(<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">8</span>);</a></code></pre></div>
<p>In this process, the parameter pack of template (typename… part of template) to perform recursive processing to expand the arguments. In the above example, since constexpr is specified, the calculation is done at compile time and the result is equivalent to macro definition or const value specification such as b2. It can also behave as a function that dynamically calculates variables as arguments.</p>
<p>In the following example, the expand_bytes function is used to store a value in a local variable from the received packet data string. In the case of using a parameter pack, since the type of each argument can be known, it is possible to store values of different sizes and types from the byte string of the received packet, as shown below.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">auto</span>&amp;&amp; rx = the_twelite.receiver.read(); <span class="co">// received packet</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">// Variable that stores the contents of the packet after expansion</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">// The payload of a packet is a sequence of bytes, arranged as follows.</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">//   [B0][B1][B2][B3][B4][B5][B6][B7][B8][B9][Ba][Bb]</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">//   &lt;message       &gt;&lt;adc*  &gt;&lt;vcc*  &gt;&lt;timestamp*    &gt;</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co">//   * Numerical types are big-endian.</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="dt">uint8_t</span> msg[MSG_LEN];</a>
<a class="sourceLine" id="cb10-9" title="9"><span class="dt">uint16_t</span> adcval, volt;</a>
<a class="sourceLine" id="cb10-10" title="10"><span class="dt">uint32_t</span> timestamp;</a>
<a class="sourceLine" id="cb10-11" title="11"></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="co">// expand packet payload</span></a>
<a class="sourceLine" id="cb10-13" title="13">expand_bytes(rx.get_payload().begin(), rx.get_payload().end()</a>
<a class="sourceLine" id="cb10-14" title="14">        , msg       <span class="co">// 4bytes of msg</span></a>
<a class="sourceLine" id="cb10-15" title="15">        , adcval    <span class="co">// 2bytes, A1 value [0..1023]</span></a>
<a class="sourceLine" id="cb10-16" title="16">      , volt      <span class="co">// 2bytes, Module VCC[mV]</span></a>
<a class="sourceLine" id="cb10-17" title="17">      , timestamp <span class="co">// 4bytes of timestamp</span></a>
<a class="sourceLine" id="cb10-18" title="18">);</a></code></pre></div>
<h3 id="iterator">Iterator</h3>
<p>An iterator is an abstraction of a pointer, which has the effect of making it possible to access data structures as if they were pointers, even if the data structures are not memory-contiguous, for example.</p>
<div class="info">
<p>In the C++ STL, the combination of an iterator indicating the beginning of the container obtained by the begin() method and an iterator indicating the “next” end of the container obtained by the end() method is often used.</p>
<p>The reason why we use end() for the “next” at the end of the container is because we expect the following description, and the MWX library follows this in its container implementation.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1">smplque&lt;<span class="dt">uint8_t</span>, alloc_local&lt;<span class="dt">uint8_t</span>, <span class="dv">5</span>&gt; &gt; que;</a>
<a class="sourceLine" id="cb11-2" title="2">que.push(<span class="ch">&#39;a&#39;</span>); que.push(<span class="ch">&#39;b&#39;</span>); que.pop(); que.push(<span class="ch">&#39;c&#39;</span>); ...</a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="kw">auto</span>&amp;&amp; p = que.begin();</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">auto</span>&amp;&amp; e = que.end();</a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="cf">while</span>(p != e) { <span class="co">// p advanced to e = all elements processed</span></a>
<a class="sourceLine" id="cb11-8" title="8">  Serial &lt;&lt; *p;</a>
<a class="sourceLine" id="cb11-9" title="9">  ++p; <span class="co">// イThe prefix operator is used for incrementing the terrator.</span></a>
<a class="sourceLine" id="cb11-10" title="10">  　　　<span class="co">// In this case, writing p++ will result in a copy of the iterator </span></a>
<a class="sourceLine" id="cb11-11" title="11">       <span class="co">// in the code, although it is likely to be optimized by the compiler.</span></a>
<a class="sourceLine" id="cb11-12" title="12">}</a></code></pre></div>
<p>Conform the iterator to the standard library specification, so that range for statements can be used, and algorithms from the standard library can be used.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode csharp"><code class="sourceCode cs"><a class="sourceLine" id="cb12-1" title="1">#include &lt;algorithm&gt;</a>
<a class="sourceLine" id="cb12-2" title="2">#include &lt;cctype&gt;</a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co">// Character conversion using lambda expressions</span></a>
<a class="sourceLine" id="cb12-5" title="5">std::<span class="fu">for_each</span>(que.<span class="fu">begin</span>(), que.<span class="fu">end</span>(), </a>
<a class="sourceLine" id="cb12-6" title="6">  [](uint8_t&amp; x) { x = std::<span class="fu">toupper</span>(x); });</a>
<a class="sourceLine" id="cb12-7" title="7"></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co">// range-for statement</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="kw">for</span> (uint8_t x : que) {</a>
<a class="sourceLine" id="cb12-10" title="10">  Serial &lt;&lt; x;</a>
<a class="sourceLine" id="cb12-11" title="11">}</a></code></pre></div>
<p>(The MWX library has not been tested for compatibility with the C++ standard library. Please check the operation before use.)</p>
</div>
<p>The following example shows the use of an iterator for a FIFO queue that cannot be accessed continuously with a normal pointer, and also an iterator that extracts only a specific member of the FIFO queue structure (the X axis in the example).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="co">//A queue with 5 elements, whose elements are the 4-axis structures of XYZT</span></a>
<a class="sourceLine" id="cb13-2" title="2">smplque&lt;axis_xyzt, alloc_local&lt;axis_xyzt, <span class="dv">5</span>&gt; &gt; que;</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co">// Input data for testing.</span></a>
<a class="sourceLine" id="cb13-5" title="5">que.push(axis_xyzt(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>));</a>
<a class="sourceLine" id="cb13-6" title="6">que.push(axis_xyzt(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>));</a>
<a class="sourceLine" id="cb13-7" title="7">...</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="co">// Access using iterators as structures</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; e : v) { Serial &lt;&lt; <span class="dt">int</span>(e.x) &lt;&lt; <span class="ch">&#39;,&#39;</span>; }</a>
<a class="sourceLine" id="cb13-11" title="11"></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="co">// Extract the X axis in the queue.</span></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="kw">auto</span>&amp;&amp; vx = get_axis_x(que);</a>
<a class="sourceLine" id="cb13-14" title="14"><span class="co">// Access with X-axis iterator</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; e : vx) { Serial &lt;&lt; <span class="dt">int</span>(e) &lt;&lt; <span class="ch">&#39;,&#39;</span>; }</a>
<a class="sourceLine" id="cb13-16" title="16"></a>
<a class="sourceLine" id="cb13-17" title="17"><span class="co">// Since it is an iterator of int16_t elements, </span></a>
<a class="sourceLine" id="cb13-18" title="18"><span class="co">//the STL algorithm (max-min) can be used.</span></a>
<a class="sourceLine" id="cb13-19" title="19"><span class="kw">auto</span>&amp;&amp; minmax = <span class="bu">std::</span>minmax_element(vx.begin(), vx.end());</a></code></pre></div>
<p> The following is an excerpt of the implementation of an iterator for the smplque class. In this iterator, the queue object is managed by its entity and its index. The part of the queue that is discontiguous in memory (ring buffer structure where the next to the tail must point to the beginning) is solved by smplque::operator []. If the addresses of the objects match and the indices match, the iterators point to the same thing.</p>
<p>This implementation part also includes the typedefs required by , allowing more STL algorithms to be applied.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">class</span> iter_smplque {</a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="kw">typedef</span> smplque&lt;T, alloc, INTCTL&gt; BODY;</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="dt">uint16_t</span> _pos; <span class="co">// index</span></a>
<a class="sourceLine" id="cb14-6" title="6">    BODY* _body;   <span class="co">// point to original object</span></a>
<a class="sourceLine" id="cb14-7" title="7"></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="kw">public</span>: <span class="co">// for &lt;iterator&gt;</span></a>
<a class="sourceLine" id="cb14-9" title="9">    <span class="kw">typedef</span> iter_smplque <span class="dt">self_type</span>;</a>
<a class="sourceLine" id="cb14-10" title="10">    <span class="kw">typedef</span> T <span class="dt">value_type</span>;</a>
<a class="sourceLine" id="cb14-11" title="11">    <span class="kw">typedef</span> T&amp; reference;</a>
<a class="sourceLine" id="cb14-12" title="12">    <span class="kw">typedef</span> T* pointer;</a>
<a class="sourceLine" id="cb14-13" title="13">    <span class="kw">typedef</span> <span class="bu">std::</span>forward_iterator_tag iterator_category;</a>
<a class="sourceLine" id="cb14-14" title="14">    <span class="kw">typedef</span> <span class="dt">int</span> <span class="dt">difference_type</span>;</a>
<a class="sourceLine" id="cb14-15" title="15"></a>
<a class="sourceLine" id="cb14-16" title="16"><span class="kw">public</span>: <span class="co">// pick some methods</span></a>
<a class="sourceLine" id="cb14-17" title="17">    <span class="kw">inline</span> reference <span class="kw">operator</span> *() {</a>
<a class="sourceLine" id="cb14-18" title="18">        <span class="cf">return</span> (*_body)[_pos];</a>
<a class="sourceLine" id="cb14-19" title="19">    }</a>
<a class="sourceLine" id="cb14-20" title="20">    </a>
<a class="sourceLine" id="cb14-21" title="21">    <span class="kw">inline</span> <span class="dt">self_type</span>&amp; <span class="kw">operator</span> ++() {</a>
<a class="sourceLine" id="cb14-22" title="22">        _pos++;</a>
<a class="sourceLine" id="cb14-23" title="23">        <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb14-24" title="24">    }</a>
<a class="sourceLine" id="cb14-25" title="25">};</a></code></pre></div>
<p>構造体を格納したコンテナ中の、特定構造体メンバーだけアクセスするイテレータは少々煩雑です。構造体のメンバーにアクセスするメンバー関数を予め定義しておきます。このメンバー関数をパラメータ（<code>R&amp; (T::*get)()</code>）としたテンプレートを定義します。<code>Iter</code>はコンテナクラスのイテレータ型です。</p>
<p>Iterators that access only specific structure members in the container that contains the structure are a bit complicated. Define a member function to access the structure members in advance. Next, define a template with this member function as a parameter (<code>R&amp; (T::*get)()</code>). “<code>Iter</code>” is the iterator type of the container class.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">struct</span> axis_xyzt {</a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="dt">int16_t</span> x, y, z;</a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="dt">uint16_t</span> t;</a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="dt">int16_t</span>&amp; get_x() { <span class="cf">return</span> x; }</a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="dt">int16_t</span>&amp; get_y() { <span class="cf">return</span> y; }</a>
<a class="sourceLine" id="cb15-6" title="6">    <span class="dt">int16_t</span>&amp; get_z() { <span class="cf">return</span> z; }</a>
<a class="sourceLine" id="cb15-7" title="7">};</a>
<a class="sourceLine" id="cb15-8" title="8"></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="kw">template</span> &lt;<span class="kw">class</span> Iter, <span class="kw">typename</span> T, <span class="kw">typename</span> R, R&amp; (T::*get)()&gt;</a>
<a class="sourceLine" id="cb15-10" title="10"><span class="kw">class</span> _iter_axis_xyzt {</a>
<a class="sourceLine" id="cb15-11" title="11">    Iter _p;</a>
<a class="sourceLine" id="cb15-12" title="12">    </a>
<a class="sourceLine" id="cb15-13" title="13"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb15-14" title="14">    <span class="kw">inline</span> <span class="dt">self_type</span>&amp; <span class="kw">operator</span> ++() {</a>
<a class="sourceLine" id="cb15-15" title="15">        _p++;</a>
<a class="sourceLine" id="cb15-16" title="16">        <span class="cf">return</span> *<span class="kw">this</span>; }</a>
<a class="sourceLine" id="cb15-17" title="17"></a>
<a class="sourceLine" id="cb15-18" title="18">    <span class="kw">inline</span> reference <span class="kw">operator</span> *() {</a>
<a class="sourceLine" id="cb15-19" title="19">        <span class="cf">return</span> (*_p.*get)(); }</a>
<a class="sourceLine" id="cb15-20" title="20">};</a>
<a class="sourceLine" id="cb15-21" title="21"></a>
<a class="sourceLine" id="cb15-22" title="22"><span class="kw">template</span> &lt;<span class="kw">class</span> Ixyz, <span class="kw">class</span> Cnt&gt;</a>
<a class="sourceLine" id="cb15-23" title="23"><span class="kw">class</span> _axis_xyzt_iter_gen {</a>
<a class="sourceLine" id="cb15-24" title="24">    Cnt&amp; _c;</a>
<a class="sourceLine" id="cb15-25" title="25">    </a>
<a class="sourceLine" id="cb15-26" title="26"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb15-27" title="27">    _axis_xyzt_iter_gen(Cnt&amp; c) : _c(c) {}</a>
<a class="sourceLine" id="cb15-28" title="28">    Ixyz begin() { <span class="cf">return</span> Ixyz(_c.begin()); }</a>
<a class="sourceLine" id="cb15-29" title="29">    Ixyz end() { <span class="cf">return</span> Ixyz(_c.end()); }</a>
<a class="sourceLine" id="cb15-30" title="30">};</a>
<a class="sourceLine" id="cb15-31" title="31"></a>
<a class="sourceLine" id="cb15-32" title="32"><span class="co">// It&#39;s long, so shorten it with using</span></a>
<a class="sourceLine" id="cb15-33" title="33"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">int16_t</span>&amp; (axis_xyzt::*get)()&gt;</a>
<a class="sourceLine" id="cb15-34" title="34"><span class="kw">using</span> _axis_xyzt_axis_ret = _axis_xyzt_iter_gen&lt;</a>
<a class="sourceLine" id="cb15-35" title="35">    _iter_axis_xyzt&lt;<span class="kw">typename</span> T::iterator, axis_xyzt, <span class="dt">int16_t</span>, get&gt;, T&gt;;</a>
<a class="sourceLine" id="cb15-36" title="36"></a>
<a class="sourceLine" id="cb15-37" title="37"><span class="co">// Generator to extract X axis</span></a>
<a class="sourceLine" id="cb15-38" title="38"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb15-39" title="39">_axis_xyzt_axis_ret&lt;T, &amp;axis_xyzt::get_x&gt;</a>
<a class="sourceLine" id="cb15-40" title="40">get_axis_x(T&amp; c) {</a>
<a class="sourceLine" id="cb15-41" title="41">    <span class="cf">return</span> _axis_xyzt_axis_ret&lt;T, &amp;axis_xyzt::get_x&gt;(c);</a>
<a class="sourceLine" id="cb15-42" title="42">}</a></code></pre></div>
<p>The <code>operator *</code> that accesses the value calls the member function described above. The <code>*_p</code> is the <code>axis_xyzt</code> structure, and <code>(*_p.*get)()</code> calls <code>_p-&gt;get_x()</code> if <code>&amp;axis_xyzt::get_x</code> is specified in <code>T::*get</code>.</p>
<p>The <code>_axis_xyzt_iter_gen</code> class implements only <code>begin()</code>, <code>end()</code> and generates the above iterators. Now you can use range for statements and algorithms.</p>
<p>This class name is very long and difficult to write in the source code. We will prepare a generator function to generate this class. In the example below, it is <code>get_axis_x()</code> in the last line. By using this generator function, the description becomes as simple as <code>auto&amp;&amp; vx = get_axis_x(que);</code> as shown in the beginning.</p>
<p>This iterator for extracting only the axes can also be used with the <code>smplbuf</code> class of array type as well.</p>
<h3 id="implementing-interrupt-event-and-state-handlers">Implementing interrupt, event, and state handlers</h3>
<p>In order to describe the application behavior by user-defined classes, typical handlers need to be defined as mandatory methods, but it is complicated to define all the other numerous interrupt handlers, event handlers, and state machine state handlers. Ideally, only those defined by the user should be defined, and only that code should be executed.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">class</span> my_app_def {</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">public</span>: <span class="co">// Define required methods</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="dt">void</span> network_event(twe::packet_ev_nwk&amp; pEvNwk) {}</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="dt">void</span> receive(twe::packet_rx&amp; rx) {}</a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="dt">void</span> transmit_complete(twe::packet_ev_tx&amp; pEvTx) {}</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="dt">void</span> loop() {}</a>
<a class="sourceLine" id="cb16-7" title="7">    <span class="dt">void</span> on_sleep(<span class="dt">uint32_t</span>&amp; val) {}</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="dt">void</span> warmboot(<span class="dt">uint32_t</span>&amp; val) {}</a>
<a class="sourceLine" id="cb16-9" title="9">    <span class="dt">void</span> wakeup(<span class="dt">uint32_t</span>&amp; val) {}</a>
<a class="sourceLine" id="cb16-10" title="10">    </a>
<a class="sourceLine" id="cb16-11" title="11"><span class="kw">public</span>: <span class="co">// It is cumbersome to make these descriptions mandatory.</span></a>
<a class="sourceLine" id="cb16-12" title="12">  <span class="co">// DIO interrupt handler: There are 20 types.</span></a>
<a class="sourceLine" id="cb16-13" title="13">  <span class="co">// DIO event handler: There are 20 types.</span></a>
<a class="sourceLine" id="cb16-14" title="14">  <span class="co">// Timer interrupt handler: There are five types</span></a>
<a class="sourceLine" id="cb16-15" title="15">  <span class="co">// Timer event handlers: there are 5 types</span></a>
<a class="sourceLine" id="cb16-16" title="16">  <span class="co">// ...</span></a>
<a class="sourceLine" id="cb16-17" title="17">}</a></code></pre></div>
<p>In the MWX library, a large number of DIO interrupt handlers (on TWELITE hardware, a single interrupt, but for ease of use, a handler is assigned to each DIO) are defined as empty handlers using templates, and user-defined member functions are defined by specializing the templates.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// hpp file</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">class</span> my_app_def : <span class="kw">class</span> app_defs&lt;my_app_def&gt;, ... {</a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="co">// Empty handler</span></a>
<a class="sourceLine" id="cb17-4" title="4">  <span class="kw">template</span>&lt;<span class="dt">int</span> N&gt; <span class="dt">void</span> int_dio_handler(<span class="dt">uint32_t</span> arg, <span class="dt">uint8_t</span>&amp; handled) { ; }</a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6">  ...   </a>
<a class="sourceLine" id="cb17-7" title="7">  <span class="co">// Implement only number 12.</span></a>
<a class="sourceLine" id="cb17-8" title="8">  </a>
<a class="sourceLine" id="cb17-9" title="9"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb17-10" title="10">  <span class="co">// Callback function called from TWENET</span></a>
<a class="sourceLine" id="cb17-11" title="11">  uint8 cbTweNet_u8HwInt(uint32 u32DeviceId, uint32 u32ItemBitmap);</a>
<a class="sourceLine" id="cb17-12" title="12">};</a>
<a class="sourceLine" id="cb17-13" title="13"></a>
<a class="sourceLine" id="cb17-14" title="14"><span class="co">// cpp file</span></a>
<a class="sourceLine" id="cb17-15" title="15"><span class="kw">template</span> &lt;&gt;</a>
<a class="sourceLine" id="cb17-16" title="16"><span class="dt">void</span> my_app_def::int_dio_handler&lt;<span class="dv">12</span>&gt;(<span class="dt">uint32_t</span> arg, <span class="dt">uint8_t</span>&amp; handled) {</a>
<a class="sourceLine" id="cb17-17" title="17">  digitalWrite(<span class="dv">5</span>, LOW);</a>
<a class="sourceLine" id="cb17-18" title="18">  handled = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb17-19" title="19">  <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb17-20" title="20">}</a>
<a class="sourceLine" id="cb17-21" title="21"></a>
<a class="sourceLine" id="cb17-22" title="22"><span class="dt">void</span> cbTweNet_u8HwInt(uint32 u32DeviceId, uint32 u32ItemBitmap) {</a>
<a class="sourceLine" id="cb17-23" title="23">  <span class="dt">uint8_t</span> b_handled = FALSE;</a>
<a class="sourceLine" id="cb17-24" title="24">  <span class="cf">switch</span>(u32DeviceId) {</a>
<a class="sourceLine" id="cb17-25" title="25">    <span class="cf">case</span> E_AHI_DEVICE_SYSCTRL:</a>
<a class="sourceLine" id="cb17-26" title="26">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">0</span>)){int_dio_handler&lt;<span class="dv">0</span>&gt;(<span class="dv">0</span>, b_handled);}</a>
<a class="sourceLine" id="cb17-27" title="27">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">1</span>)){int_dio_handler&lt;<span class="dv">1</span>&gt;(<span class="dv">1</span>, b_handled);}</a>
<a class="sourceLine" id="cb17-28" title="28">      ...</a>
<a class="sourceLine" id="cb17-29" title="29">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">12</span>)){int_dio_handler&lt;<span class="dv">12</span>&gt;(<span class="dv">12</span>, b_handled);}</a>
<a class="sourceLine" id="cb17-30" title="30">      ...</a>
<a class="sourceLine" id="cb17-31" title="31">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">19</span>)){int_dio_handler&lt;<span class="dv">19</span>&gt;(<span class="dv">19</span>, b_handled);}</a>
<a class="sourceLine" id="cb17-32" title="32">    <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb17-33" title="33">  }</a>
<a class="sourceLine" id="cb17-34" title="34">}</a></code></pre></div>
<p>The actual user-described code has been simplified by macroizing and including header files, but the above includes the code necessary for the explanation.</p>
<p>The <code>my_app_def::cbTweNet_u8HwInt()</code> is called from the interrupt handler from TWENET. in the cpp file, only <code>int_dio_handler&lt;12&gt;</code> is instantiated with the specialization described in it. file is instantiated from a template in the hpp file. The rest are instantiated from templates in the hpp file.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1">    <span class="cf">case</span> E_AHI_DEVICE_SYSCTRL:</a>
<a class="sourceLine" id="cb18-2" title="2">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">0</span>)){;}</a>
<a class="sourceLine" id="cb18-3" title="3">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">1</span>)){;}</a>
<a class="sourceLine" id="cb18-4" title="4">      ...</a>
<a class="sourceLine" id="cb18-5" title="5">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">12</span>)){</a>
<a class="sourceLine" id="cb18-6" title="6">          int_dio_handler&lt;<span class="dv">12</span>&gt;(<span class="dv">12</span>, b_handled);}</a>
<a class="sourceLine" id="cb18-7" title="7">      ...</a>
<a class="sourceLine" id="cb18-8" title="8">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">19</span>)){;}</a>
<a class="sourceLine" id="cb18-9" title="9">      <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb18-10" title="10">      </a>
<a class="sourceLine" id="cb18-11" title="11">    <span class="co">// ↓　↓　↓</span></a>
<a class="sourceLine" id="cb18-12" title="12">    </a>
<a class="sourceLine" id="cb18-13" title="13">    <span class="co">// 結局、このように最適化されることが期待できる。</span></a>
<a class="sourceLine" id="cb18-14" title="14">    <span class="cf">case</span> E_AHI_DEVICE_SYSCTRL:</a>
<a class="sourceLine" id="cb18-15" title="15">      <span class="cf">if</span> (u32ItemBitmap &amp; (<span class="dv">1</span><span class="bu">UL</span> &lt;&lt; <span class="dv">12</span>)){</a>
<a class="sourceLine" id="cb18-16" title="16">        <span class="co">// int_dio_handler&lt;12&gt; もinline展開</span></a>
<a class="sourceLine" id="cb18-17" title="17">        digitalWrite(<span class="dv">5</span>, LOW);</a>
<a class="sourceLine" id="cb18-18" title="18">        handled = <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb18-19" title="19">      }</a>
<a class="sourceLine" id="cb18-20" title="20">      <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb18-21" title="21">    </a></code></pre></div>
<p>Eventually, we can expect that the compiler optimization will determine that codes other than number 12 are meaningless and disappear from the code (however, we do not guarantee that they will be optimized as described above).</p>
<p>In other words, in user code, if you want to define the behavior at interrupt 12, just write <code>int_dio_handler&lt;12&gt;</code> (Note: to enable DIO interrupt, you need to call <code>attachInterrupt()</code>). Handlers that are not registered are expected to be low-cost calls due to compile-time optimization.</p>
<div class="info">
<p>One technique to enable this when the user defines a function, and call another function if not defined, is to resolve it at link time. Specify <code>__attribute__((wake))</code> as shown below. If the <code>wakeup()</code> function is defined in the user code, the user code will be linked to the function, and if it is not defined, the function with empty content will be linked.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// mwx_appcore.cpp</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="dt">void</span> wakeup() __attribute__((weak));</a>
<a class="sourceLine" id="cb19-3" title="3"><span class="dt">void</span> wakeup() { }</a></code></pre></div>
<p>In the implementation of the above handler, it is necessary to generate weak member variables explicitly, and it is difficult to optimize by inlining, so it is not used. However, weak functions are defined to receive some callbacks from TWENET, such as <code>wakeup()</code>.</p>
</div>
<h3 id="stream-class">Stream class</h3>
<p>The stream class is mainly used for input/output of UART (serial port), and MWX library mainly defines procedures for output. But some of them are also defined for input.</p>
<p>This section describes the implementation required by the derived class.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">template</span> &lt;<span class="kw">class</span> D&gt;</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="kw">class</span> stream {</a>
<a class="sourceLine" id="cb20-3" title="3"><span class="kw">protected</span>:</a>
<a class="sourceLine" id="cb20-4" title="4">    <span class="dt">void</span>* pvOutputContext; <span class="co">// TWE_tsFILE*</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb20-6" title="6">  <span class="kw">inline</span> D* get_Derived() { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;D*&gt;(<span class="kw">this</span>); }</a>
<a class="sourceLine" id="cb20-7" title="7">    <span class="kw">inline</span> D&amp; <span class="kw">operator</span> &lt;&lt; (<span class="dt">char</span> c) {</a>
<a class="sourceLine" id="cb20-8" title="8">        get_Derived()-&gt;write(c);</a>
<a class="sourceLine" id="cb20-9" title="9">        <span class="cf">return</span> *get_Derived();</a>
<a class="sourceLine" id="cb20-10" title="10">    }</a>
<a class="sourceLine" id="cb20-11" title="11">};</a>
<a class="sourceLine" id="cb20-12" title="12"></a>
<a class="sourceLine" id="cb20-13" title="13"><span class="kw">class</span> serial_jen : <span class="kw">public</span> mwx::stream&lt;serial_jen&gt; {</a>
<a class="sourceLine" id="cb20-14" title="14"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb20-15" title="15">    <span class="kw">inline</span> <span class="dt">size_t</span> write(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb20-16" title="16">        <span class="cf">return</span> (<span class="dt">int</span>)SERIAL_bTxChar(_serdef._u8Port, n);</a>
<a class="sourceLine" id="cb20-17" title="17">    }</a>
<a class="sourceLine" id="cb20-18" title="18">};</a></code></pre></div>
<p>The above is an implementation of the <code>write()</code> method that writes a single character. The <code>stream&lt;serial_jen&gt;</code> of the parent class accesses the <code>serial_jen::write()</code> method using the <code>get_Drived()</code> method to perform casting.</p>
<p>Define methods such as <code>write()</code>, <code>read()</code>, <code>flush()</code>, and <code>available()</code> as needed.</p>
<p>For formatting output, we use Marco Paland’s <a target=_blank href="https://github.com/mpaland/printf">printf library</a>, which needs to be implemented for use with the MWX library. In the following example, the derived class <code>serial_jen</code> needs to define the <code>vOutput()</code> method for 1-byte output, and save the auxiliary information for output in the parent class <code>pvOutputContext</code> since <code>vOutput()</code> is a static method. The other is to save the auxiliary information in the <code>pvOutputContext</code> of the parent class since <code>vOutput()</code> is a static method.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">template</span> &lt;<span class="kw">class</span> D&gt;</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="kw">class</span> stream {</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">protected</span>:</a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="dt">void</span>* pvOutputContext; <span class="co">// TWE_tsFILE*</span></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="kw">inline</span> tfcOutput get_pfcOutout() { <span class="cf">return</span> get_Derived()-&gt;vOutput; }</a>
<a class="sourceLine" id="cb21-7" title="7">    </a>
<a class="sourceLine" id="cb21-8" title="8">    <span class="kw">inline</span> D&amp; <span class="kw">operator</span> &lt;&lt; (<span class="dt">int</span> i) {</a>
<a class="sourceLine" id="cb21-9" title="9">        (<span class="dt">size_t</span>)fctprintf(get_pfcOutout(), pvOutputContext, <span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>, i);</a>
<a class="sourceLine" id="cb21-10" title="10">        <span class="cf">return</span> *get_Derived();</a>
<a class="sourceLine" id="cb21-11" title="11">    }</a>
<a class="sourceLine" id="cb21-12" title="12">};</a>
<a class="sourceLine" id="cb21-13" title="13"></a>
<a class="sourceLine" id="cb21-14" title="14"><span class="kw">class</span> serial_jen : <span class="kw">public</span> mwx::stream&lt;serial_jen&gt; {</a>
<a class="sourceLine" id="cb21-15" title="15">    <span class="kw">using</span> SUPER = mwx::stream&lt;serial_jen&gt;;</a>
<a class="sourceLine" id="cb21-16" title="16">    TWE_tsFILE* _psSer; <span class="co">// Low-level structure for serial output</span></a>
<a class="sourceLine" id="cb21-17" title="17"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb21-18" title="18">  <span class="dt">void</span> begin() {</a>
<a class="sourceLine" id="cb21-19" title="19">    SUPER::pvOutputContext = (<span class="dt">void</span>*)_psSer;</a>
<a class="sourceLine" id="cb21-20" title="20">  }</a>
<a class="sourceLine" id="cb21-21" title="21">  </a>
<a class="sourceLine" id="cb21-22" title="22">    <span class="at">static</span> <span class="dt">void</span> vOutput(<span class="dt">char</span> out, <span class="dt">void</span>* vp) {</a>
<a class="sourceLine" id="cb21-23" title="23">        TWE_tsFILE* fp = (TWE_tsFILE*)vp;</a>
<a class="sourceLine" id="cb21-24" title="24">        fp-&gt;fp_putc(out, fp);</a>
<a class="sourceLine" id="cb21-25" title="25">    }</a>
<a class="sourceLine" id="cb21-26" title="26">};</a></code></pre></div>
<p>By <code>get_pfcOutput()</code>, the <code>vOutput()</code> function defined in the derived class is specified, and <code>pvOutputContext</code> is passed as its parameter. In the above example, when the <code>&lt;&lt;</code> operator is called with int type, <code>serial_jen::vOutput()</code> and <code>TWE_tsFILE*</code> which is already set for UART are passed to the <code>fctprintf()</code> function.</p>
<h3 id="worker-object-for-wire-spi">Worker object for Wire, SPI</h3>
<p>In the Wire class, it is necessary to manage the communication from start to end when sending and receiving with a 2-wire device. This section describes the contents of the description of using the worker object.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="cf">if</span> (<span class="kw">auto</span>&amp;&amp; wrt = Wire.get_writer(SHTC3_ADDRESS)) {</a>
<a class="sourceLine" id="cb22-2" title="2">    Serial &lt;&lt; <span class="st">&quot;{I2C SHTC3 connected.&quot;</span>;</a>
<a class="sourceLine" id="cb22-3" title="3">    wrt &lt;&lt; SHTC3_TRIG_H;</a>
<a class="sourceLine" id="cb22-4" title="4">    wrt &lt;&lt; SHTC3_TRIG_L;</a>
<a class="sourceLine" id="cb22-5" title="5">    Serial &lt;&lt; <span class="st">&quot; end}&quot;</span>;</a>
<a class="sourceLine" id="cb22-6" title="6">}</a></code></pre></div>
<p>This is an excerpt of the <code>periph_twowire::writer</code> class, which inherits from <code>mwx::stream&lt;writer&gt;</code> to implement the stream interface, and implements the <code>write()</code> and <code>vOutput()</code> methods to use the steam interface. To use the steam interface, the <code>write()</code> and `vOutput() methods are implemented.</p>
<p>The constructor calls the method to start communication for 2-wire serial and the destructor calls the method to end communication. Also, the <code>operator bool()</code> operator returns true if the communication of the 2-wire serial device is successfully started.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">class</span> periph_twowire {</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb23-3" title="3">    <span class="kw">class</span> writer : <span class="kw">public</span> mwx::stream&lt;writer&gt; {</a>
<a class="sourceLine" id="cb23-4" title="4">        <span class="kw">friend</span> <span class="kw">class</span> mwx::stream&lt;writer&gt;;</a>
<a class="sourceLine" id="cb23-5" title="5">        periph_twowire&amp; _wire;</a>
<a class="sourceLine" id="cb23-6" title="6">    </a>
<a class="sourceLine" id="cb23-7" title="7">    <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb23-8" title="8">        writer(periph_twowire&amp; ref, <span class="dt">uint8_t</span> devid) : _wire(ref) {</a>
<a class="sourceLine" id="cb23-9" title="9">        _wire.beginTransmission(devid); <span class="co">// Start communication with constructor</span></a>
<a class="sourceLine" id="cb23-10" title="10">        }</a>
<a class="sourceLine" id="cb23-11" title="11">    </a>
<a class="sourceLine" id="cb23-12" title="12">        ~writer() {</a>
<a class="sourceLine" id="cb23-13" title="13">            _wire.endTransmission(); <span class="co">// Communication terminated by destructor</span></a>
<a class="sourceLine" id="cb23-14" title="14">        }</a>
<a class="sourceLine" id="cb23-15" title="15">    </a>
<a class="sourceLine" id="cb23-16" title="16">        <span class="kw">operator</span> <span class="dt">bool</span>() {</a>
<a class="sourceLine" id="cb23-17" title="17">            <span class="cf">return</span> (_wire._mode == periph_twowire::MODE_TX);</a>
<a class="sourceLine" id="cb23-18" title="18">        }</a>
<a class="sourceLine" id="cb23-19" title="19">    </a>
<a class="sourceLine" id="cb23-20" title="20">    <span class="kw">private</span>: <span class="co">// stream interface</span></a>
<a class="sourceLine" id="cb23-21" title="21">        <span class="kw">inline</span> <span class="dt">size_t</span> write(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb23-22" title="22">            <span class="cf">return</span> _wire.write(val);</a>
<a class="sourceLine" id="cb23-23" title="23">        }</a>
<a class="sourceLine" id="cb23-24" title="24">    </a>
<a class="sourceLine" id="cb23-25" title="25">        <span class="co">// for upper class use</span></a>
<a class="sourceLine" id="cb23-26" title="26">        <span class="at">static</span> <span class="dt">void</span> vOutput(<span class="dt">char</span> out, <span class="dt">void</span>* vp) {</a>
<a class="sourceLine" id="cb23-27" title="27">            periph_twowire* p_wire = (periph_twowire*)vp;</a>
<a class="sourceLine" id="cb23-28" title="28">            <span class="cf">if</span> (p_wire != <span class="kw">nullptr</span>) {</a>
<a class="sourceLine" id="cb23-29" title="29">                p_wire-&gt;write(<span class="dt">uint8_t</span>(out));</a>
<a class="sourceLine" id="cb23-30" title="30">            }</a>
<a class="sourceLine" id="cb23-31" title="31">        }</a>
<a class="sourceLine" id="cb23-32" title="32">    };</a>
<a class="sourceLine" id="cb23-33" title="33">    </a>
<a class="sourceLine" id="cb23-34" title="34"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb23-35" title="35">    writer get_writer(<span class="dt">uint8_t</span> address) {</a>
<a class="sourceLine" id="cb23-36" title="36">        <span class="cf">return</span> writer(*<span class="kw">this</span>, address);</a>
<a class="sourceLine" id="cb23-37" title="37">    }</a>
<a class="sourceLine" id="cb23-38" title="38">};</a>
<a class="sourceLine" id="cb23-39" title="39"><span class="kw">class</span> periphe_twowire Wire; <span class="co">// global instance</span></a>
<a class="sourceLine" id="cb23-40" title="40"></a>
<a class="sourceLine" id="cb23-41" title="41"><span class="co">// ユーザコード</span></a>
<a class="sourceLine" id="cb23-42" title="42"><span class="cf">if</span> (<span class="kw">auto</span>&amp;&amp; wrt = Wire.get_writer(SHTC3_ADDRESS)) {</a>
<a class="sourceLine" id="cb23-43" title="43">    Serial &lt;&lt; <span class="st">&quot;{I2C SHTC3 connected.&quot;</span>;</a>
<a class="sourceLine" id="cb23-44" title="44">    wrt &lt;&lt; SHTC3_TRIG_H;</a>
<a class="sourceLine" id="cb23-45" title="45">    wrt &lt;&lt; SHTC3_TRIG_L;</a>
<a class="sourceLine" id="cb23-46" title="46">    Serial &lt;&lt; <span class="st">&quot; end}&quot;</span>;</a>
<a class="sourceLine" id="cb23-47" title="47">}</a></code></pre></div>
<p>The <code>get_writer()</code> method creates an object <code>wrt</code>. Due to the Return Value Optimization (RVO) of the C++ compiler, the <code>writer</code> is created directly in the <code>wrt</code>, so no copy is made and the bus running in the constructor is not initialized multiple times. However, RVO is not guaranteed by the C++ specification, and just in case, the MWX library defines copy, delete assignment operators, and move constructors (although it is unlikely that move constructors will be evaluated).</p>
<p>The wrt in the if clause is first initialized by the constructor and starts communication at the same time. If there is no error at the start of communication, the bool operator at the time of conditional judgment returns true, and the processing in the scope of the if clause takes place. If there is no error at the start of communication, the bool operator at the conditional judgment returns true, and the processing in the if clause scope is performed. When the scope is exited, the destructor terminates the 2-wire serial bus. If there is no communication partner, false will be returned and the wrt object will be destroyed.</p>
<p>It overrides the definition of <code>operator &lt;&lt; (int)</code>, which is specific to Wire and SPI. The default behavior of the stream is to convert numeric values to strings and output them, but Wire and SPI rarely write numeric strings to the bus, and on the contrary, we often want to input literals of numeric type such as configuration values. We will change this behavior.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1">            writer&amp; <span class="kw">operator</span> &lt;&lt; (<span class="dt">int</span> v) {</a>
<a class="sourceLine" id="cb24-2" title="2">                _wire.write(<span class="dt">uint8_t</span>(v &amp; <span class="bn">0xFF</span>));</a>
<a class="sourceLine" id="cb24-3" title="3">                <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb24-4" title="4">            }</a></code></pre></div>
<p>In this example, the int type values are truncated to 8 bits and the values are output.</p>
</body>
</html>
