<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mono Wireless Inc." />
  <title>Slp_Wk_and_Tx</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Slp_Wk_and_Tx</h1>
<p class="author">Mono Wireless Inc.</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#slp_wk_and_tx">Slp_Wk_and_Tx</a><ul>
<li><a href="#act-features.">ACT features.</a></li>
<li><a href="#description-of-the-act">Description of the ACT</a><ul>
<li><a href="#declarations">Declarations</a></li>
<li><a href="#setup">setup()</a></li>
<li><a href="#begin">begin()</a></li>
<li><a href="#wakeup">wakeup()</a></li>
<li><a href="#loop">loop()</a></li>
<li><a href="#sleepnow">SleepNow()</a></li>
<li><a href="#transmit">Transmit()</a></li>
<li><a href="#on_tx_comp">on_tx_comp()</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="slp_wk_and_tx">Slp_Wk_and_Tx</h1>
<p>Slp_Wk_and_Tx is a template source code for an application which, after a regular wake-up, does something (e.g. acquires sensor data) and sends the result as a wireless packet.</p>
<p>In the form of <code>setup()</code> and <code>loop()</code>, conditional branches which are difficult to read in <code>loop()</code> tend to occur. In this Act, we use <a href="../api-reference/classes/smsimple-suttomashin.html">SM_SIMPLE state machine</a> in <code>loop()</code> and simple state transition by switch syntax to improve the visibility of the code.</p>
<div class="success">
<p>This act includes</p>
<ul>
<li>The control structure of a typical intermittent operation (sleep -&gt; wake -&gt; measure -&gt; radio transmission -&gt; sleep)</li>
<li>Generation and transmission procedures for outgoing packets and waiting for completion</li>
</ul>
</div>
<h2 id="act-features.">ACT features.</h2>
<ul>
<li>After starting up, the system goes through an initialization process and then goes to sleep.
<ol type="1">
<li><code>setup()</code>Initialise</li>
<li><code>begin()</code> Run sleep</li>
</ol></li>
<li>After waking up from sleep, the state variables are initialized and the actions are performed in the following order
<ol type="1">
<li><code>wakeup()</code> wakes up from sleep, performs each initialization</li>
<li><code>loop()/INIT-&gt;WORK_JOB state</code>: does some processing (in this Act, the counter is updated every TickCount for 1ms and moves to TX state after a count determined by a random number)</li>
<li><code>loop()/TX state</code>: Make a request to send</li>
<li><code>loop()/WAIT_TX state</code>: Waiting for transmission completion</li>
<li><code>loop()/EXIT_NORMAL state</code>: Run sleep (back to 1.)</li>
</ol></li>
<li><code>loop()/EXIT_FATAL state</code> :Resetting the module if an error occurs</li>
</ul>
<h2 id="description-of-the-act">Description of the ACT</h2>
<h3 id="declarations">Declarations</h3>
<h4 id="includes">Includes</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;TWELITE&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;NWK_SIMPLE&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;SM_SIMPLE&gt;</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="pp">#include </span><span class="im">&quot;Common.h&quot;</span></a></code></pre></div>
<p>To send packets, <code>&lt;NWK_SIMPLE&gt;</code> is included. Also, basic definitions such as application ID are in <code>&quot;Common.h&quot;</code>.</p>
<h4 id="state-definition.">State definition.</h4>
<p>In order to describe the sequential processing in <code>loop()</code>, this sample uses the concept of a state machine (state transition). It uses <code>&lt;SM_SIMPLE&gt;</code>, which summarizes the processing of very simple state transitions.</p>
<p>An enum <code>STATE</code> is defined in <code>Common.h</code> for the following states.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">enum</span> <span class="kw">class</span> STATE {</a>
<a class="sourceLine" id="cb2-2" title="2">    INIT = <span class="dv">0</span>,    <span class="co">// INIT STATE</span></a>
<a class="sourceLine" id="cb2-3" title="3">    WORK_JOB,    <span class="co">// do some job (e.g sensor capture)</span></a>
<a class="sourceLine" id="cb2-4" title="4">    TX,          <span class="co">// reuest transmit</span></a>
<a class="sourceLine" id="cb2-5" title="5">    WAIT_TX,     <span class="co">// wait its completion</span></a>
<a class="sourceLine" id="cb2-6" title="6">    EXIT_NORMAL, <span class="co">// normal exiting.</span></a>
<a class="sourceLine" id="cb2-7" title="7">    EXIT_FATAL   <span class="co">// has a fatal error (will do system reset)</span></a>
<a class="sourceLine" id="cb2-8" title="8">};</a></code></pre></div>
<p>Declares an <a href="../api-reference/classes/smsimple-suttomashin.html">SM_SIMPLE state machine</a> (state transition) using the <code>STATE</code> state enumeration.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">SM_SIMPLE&lt;STATE&gt; step;</a></code></pre></div>
<p>The <code>step</code> declared here contains functions for managing state, timeouts and waiting for processing.</p>
<h4 id="sensor-data.">Sensor data.</h4>
<p>In this sample we do not process the sensor data, but we prepare dummy data for explanation.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="dt">uint16_t</span> dummy_work_ct_now;</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dt">uint16_t</span> dummy_work_ct_max;  <span class="co">// counter for dummy work job. </span></a>
<a class="sourceLine" id="cb4-4" title="4">} sensor;</a></code></pre></div>
<h3 id="setup">setup()</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> setup() {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="co">/*** SETUP section */</span></a>
<a class="sourceLine" id="cb5-3" title="3">    step.setup(); <span class="co">// init state machine</span></a>
<a class="sourceLine" id="cb5-4" title="4">    </a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="co">// the twelite main class</span></a>
<a class="sourceLine" id="cb5-6" title="6">    the_twelite</a>
<a class="sourceLine" id="cb5-7" title="7">        &lt;&lt; TWENET::appid(APP_ID)    <span class="co">// set application ID (identify network group)</span></a>
<a class="sourceLine" id="cb5-8" title="8">        &lt;&lt; TWENET::channel(CHANNEL) <span class="co">// set channel (pysical channel)</span></a>
<a class="sourceLine" id="cb5-9" title="9">        &lt;&lt; TWENET::rx_when_idle(<span class="kw">false</span>);  <span class="co">// open receive circuit (if not set, it can&#39;t listen packts from others)</span></a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="co">// Register Network</span></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="kw">auto</span>&amp;&amp; nwk = the_twelite.network.use&lt;NWK_SIMPLE&gt;();</a>
<a class="sourceLine" id="cb5-13" title="13">    nwk &lt;&lt; NWK_SIMPLE::logical_id(DEVICE_ID); <span class="co">// set Logical ID. </span></a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="co">/*** </span><span class="re">BEGIN</span><span class="co"> section */</span></a>
<a class="sourceLine" id="cb5-16" title="16">    the_twelite.begin(); <span class="co">// start twelite!</span></a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="co">/*** INIT message */</span></a>
<a class="sourceLine" id="cb5-19" title="19">    Serial &lt;&lt; <span class="st">&quot;--- Sleep an Tx Act ---&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb5-20" title="20">}</a></code></pre></div>
<p>Initializes variables and class objects.</p>
<ul>
<li>Initialization of the <code>step</code> state machine</li>
<li>Initialization of <code>the_twelite</code> class object</li>
<li>Register and initialize the network <code>&lt;NWK_SIMPLE&gt;</code> (register <code>DEVICE_ID</code>).</li>
</ul>
<p>This is followed by the initiation of class objects and hardware.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">the_twelite.begin(); <span class="co">// start twelite!</span></a></code></pre></div>
<p>This is the procedure to start <code>the_twelite</code>, it didn’t appear in act0..4, but you should call it if you set up <code>the_twelite</code> or register various behaviors.</p>
<h3 id="begin">begin()</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">void</span> begin() {</a>
<a class="sourceLine" id="cb7-2" title="2">    Serial &lt;&lt; <span class="st">&quot;..begin (run once at boot)&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb7-3" title="3">    SleepNow();</a>
<a class="sourceLine" id="cb7-4" title="4">}</a></code></pre></div>
<p>Called only once, immediately after <code>setup()</code>. The <code>SleepNow()</code> function is called to perform the first sleep procedure.</p>
<h3 id="wakeup">wakeup()</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">void</span> wakeup() {</a>
<a class="sourceLine" id="cb8-2" title="2">　memset(&amp;sensor, <span class="dv">0</span>, <span class="kw">sizeof</span>(sensor));</a>
<a class="sourceLine" id="cb8-3" title="3">    Serial &lt;&lt; crlf &lt;&lt; <span class="dt">int</span>(millis()) &lt;&lt; <span class="st">&quot;:wake up!&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb8-4" title="4">}</a></code></pre></div>
<p>Called immediately after waking up. Here, it initializes the sensor data area and outputs a message on waking.</p>
<h3 id="loop">loop()</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">void</span> loop() {</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="cf">do</span> {</a>
<a class="sourceLine" id="cb9-3" title="3">        <span class="cf">switch</span>(step.state()) {</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="cf">case</span> STATE::INIT:</a>
<a class="sourceLine" id="cb9-5" title="5">            sensor.dummy_work_ct_now = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb9-6" title="6">            sensor.dummy_work_ct_max = random(<span class="dv">10</span>,<span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb9-7" title="7">            step.next(STATE::WORK_JOB);</a>
<a class="sourceLine" id="cb9-8" title="8">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb9-9" title="9"></a>
<a class="sourceLine" id="cb9-10" title="10">        ...</a>
<a class="sourceLine" id="cb9-11" title="11">        }</a>
<a class="sourceLine" id="cb9-12" title="12">    } <span class="cf">while</span> (step.b_more_loop());</a>
<a class="sourceLine" id="cb9-13" title="13">}</a></code></pre></div>
<p>The above code is a simplified version of the actual code.</p>
<p>This control structure uses the <a href="../api-reference/classes/smsimple-suttomashin.html">SM_SIMPLE state machine</a>. It is a loop with <em><code>do..while()</code></em> syntax. Inside the loop is a <em><code>switch case</code> </em> clause, which splits the process according to the state obtained by <code>.state()</code>. State transitions call <code>.next()</code> to rewrite internal variables in the state machine to the new state values.</p>
<p><code>step.b_more_loop()</code> is set to true if there is a state transition by <code>.next()</code>. The purpose of this is to execute the code of the next state (<em>case clause</em>) without escaping <code>loop()</code> when a state transition occurs.</p>
<p>Below is a description of each state.</p>
<h4 id="stateinit">STATE::INIT</h4>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1">sensor.dummy_work_ct_now = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb10-2" title="2">sensor.dummy_work_ct_max = random(<span class="dv">10</span>,<span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb10-3" title="3"></a>
<a class="sourceLine" id="cb10-4" title="4">step.next(STATE::WORK_JOB);</a></code></pre></div>
<p>Initialises the sensor values of the dummies. One is determined randomly by an add counter and one by a counter stop value.</p>
<h4 id="statework_job">STATE::WORK_JOB</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="cf">if</span> (TickTimer.available()) {</a>
<a class="sourceLine" id="cb11-2" title="2">    Serial &lt;&lt; <span class="ch">&#39;.&#39;</span>;</a>
<a class="sourceLine" id="cb11-3" title="3">    sensor.dummy_work_ct_now++;</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="cf">if</span> (sensor.dummy_work_ct_now &gt;= sensor.dummy_work_ct_max) {</a>
<a class="sourceLine" id="cb11-5" title="5">        Serial &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb11-6" title="6">        step.next(STATE::TX);</a>
<a class="sourceLine" id="cb11-7" title="7">    }</a>
<a class="sourceLine" id="cb11-8" title="8">}</a></code></pre></div>
<p>In the WORK_JOB state, we work on a timer every 1ms; every Tick timer becomes <code>TickTimer.available()</code>; every Tick timer adds a counter and when it reaches <code>dummy_work_ct_max</code>, we move to the next state <code>STATE::TX</code> .</p>
<h4 id="statetx">STATE::TX</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="cf">if</span> (Transmit()) {</a>
<a class="sourceLine" id="cb12-2" title="2">    Serial &lt;&lt; <span class="dt">int</span>(millis()) &lt;&lt; <span class="st">&quot;:tx request success!&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb12-3" title="3">    step.set_timeout(<span class="dv">100</span>);</a>
<a class="sourceLine" id="cb12-4" title="4">    step.clear_flag();</a>
<a class="sourceLine" id="cb12-5" title="5">    step.next(STATE::WAIT_TX);</a>
<a class="sourceLine" id="cb12-6" title="6">} <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="co">// normall it should not be here.</span></a>
<a class="sourceLine" id="cb12-8" title="8">    Serial &lt;&lt; <span class="dt">int</span>(millis()) &lt;&lt; <span class="st">&quot;!FATAL: tx request failed.&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb12-9" title="9">    step.next(STATE::EXIT_FATAL);</a>
<a class="sourceLine" id="cb12-10" title="10">}</a></code></pre></div>
<p>Call the <code>Transmit()</code> function to request packet transmission. If the request succeeds, the function transits to <code>STATE::WAIT_TXEVENT</code> and waits for the completion of transmission. Here, we use the timeout and flag functions of the SM_SIMPLE state machine to wait for completion (it is simple to determine the value of a variable by changing its value in the waiting loop).</p>
<p>We don’t usually expect a single request to fail, but if it does, it will go to the <code>STATE::EXIT_FATAL</code> exception handling state.</p>
<div class="warning">
<p>You should not sleep at this point, as the packet has not yet been sent. In most cases, you should <strong>wait for transmission to complete</strong> before continuing.</p>
</div>
<div class="info">
<p>The <code>Transmit()</code> function returns a <code>MWX_APIRET</code> object, which holds a bool type success or failure and a value of up to 31 bits. It can be evaluated as a <code>bool</code> type, so an <code>if</code> statement will return <code>true</code> if the send request succeeds, or <code>false</code> if it fails.</p>
</div>
<h4 id="statewait_tx">STATE::WAIT_TX</h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="cf">if</span> (step.is_flag_ready()) {</a>
<a class="sourceLine" id="cb13-2" title="2">    Serial &lt;&lt; <span class="dt">int</span>(millis()) &lt;&lt; <span class="st">&quot;:tx completed!&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb13-3" title="3">    step.next(STATE::EXIT_NORMAL);</a>
<a class="sourceLine" id="cb13-4" title="4">} <span class="cf">else</span> <span class="cf">if</span> (step.is_timeout()) {</a>
<a class="sourceLine" id="cb13-5" title="5">    Serial &lt;&lt; <span class="dt">int</span>(millis()) &lt;&lt; <span class="st">&quot;!FATAL: tx timeout.&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb13-6" title="6">    step.next(STATE::EXIT_FATAL);</a>
<a class="sourceLine" id="cb13-7" title="7">}</a></code></pre></div>
<p>Waiting for completion of transmission is judged by setting the flag of the state machine function with <code>on_tx_comp()</code> described later. The timeout is judged by the elapsed time since <code>.set_timeout()</code> was done by calling <code>.is_timeout()</code>.</p>
<p>Normally you will get a completion notice whether the transmission succeeds or fails, but it will time out and go to <code>STATE::EXIT_FATAL</code> for exception handling.</p>
<h4 id="stateexit_normal">STATE::EXIT_NORMAL</h4>
<pre><code>SleepNow();</code></pre>
<p>Call <code>SleepNow()</code> to start the sleep process.</p>
<h4 id="stateexit_fatal">STATE::EXIT_FATAL</h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1">Serial &lt;&lt; crlf &lt;&lt; <span class="st">&quot;!FATAL: RESET THE SYSTEM.&quot;</span>;</a>
<a class="sourceLine" id="cb15-2" title="2">delay(<span class="dv">1000</span>); <span class="co">// wait a while.</span></a>
<a class="sourceLine" id="cb15-3" title="3">the_twelite.reset_system();</a></code></pre></div>
<p>As a critical error, a system reset is performed.</p>
<h3 id="sleepnow">SleepNow()</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="dt">void</span> SleepNow() {</a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="dt">uint16_t</span> u16dur = SLEEP_DUR;</a>
<a class="sourceLine" id="cb16-3" title="3">    u16dur = random(SLEEP_DUR - SLEEP_DUR_TERMOR, SLEEP_DUR + SLEEP_DUR_TERMOR);</a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5">    Serial &lt;&lt; <span class="dt">int</span>(millis()) &lt;&lt; <span class="st">&quot;:sleeping for &quot;</span> &lt;&lt; <span class="dt">int</span>(u16dur) &lt;&lt; <span class="st">&quot;ms&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb16-6" title="6">    Serial.flush();</a>
<a class="sourceLine" id="cb16-7" title="7"></a>
<a class="sourceLine" id="cb16-8" title="8">    step.on_sleep(); <span class="co">// reset status of statemachine to INIT state.</span></a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10">    the_twelite.sleep(u16dur, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb16-11" title="11">}</a></code></pre></div>
<p>Periodic sleep is performed. The sleep time is set to a constant time blur using the <code>random()</code> function. This is because when the transmission cycles of several devices are synchronized, the failure rate may increase significantly.</p>
<p>Before sleeping, the state of the SM_SIMPLE state machine is set by calling <code>.on_sleep()</code>.</p>
<h3 id="transmit">Transmit()</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1">MWX_APIRET vTransmit() {</a>
<a class="sourceLine" id="cb17-2" title="2">    Serial &lt;&lt; <span class="dt">int</span>(millis()) &lt;&lt; <span class="st">&quot;:vTransmit()&quot;</span> &lt;&lt; crlf;</a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="cf">if</span> (<span class="kw">auto</span>&amp;&amp; pkt = the_twelite.network.use&lt;NWK_SIMPLE&gt;().prepare_tx_packet()) {</a>
<a class="sourceLine" id="cb17-5" title="5">        <span class="co">// set tx packet behavior</span></a>
<a class="sourceLine" id="cb17-6" title="6">        pkt &lt;&lt; tx_addr(<span class="bn">0x00</span>)  <span class="co">// 0..0xFF (LID 0:parent, FE:child w/ no id, FF:LID broad cast), 0x8XXXXXXX (long address)</span></a>
<a class="sourceLine" id="cb17-7" title="7">            &lt;&lt; tx_retry(<span class="bn">0x1</span>) <span class="co">// set retry (0x3 send four times in total)</span></a>
<a class="sourceLine" id="cb17-8" title="8">            &lt;&lt; tx_packet_delay(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>); <span class="co">// send packet w/ delay (send first packet with randomized delay from 0 to 0ms, repeat every 2ms)</span></a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10">        <span class="co">// prepare packet payload</span></a>
<a class="sourceLine" id="cb17-11" title="11">        pack_bytes(pkt.get_payload() <span class="co">// set payload data objects.</span></a>
<a class="sourceLine" id="cb17-12" title="12">            , make_pair(FOURCC, <span class="dv">4</span>) <span class="co">// string should be paired with length explicitly.</span></a>
<a class="sourceLine" id="cb17-13" title="13">            , <span class="dt">uint32_t</span>(millis()) <span class="co">// put timestamp here.</span></a>
<a class="sourceLine" id="cb17-14" title="14">            , <span class="dt">uint16_t</span>(sensor.dummy_work_ct_now) <span class="co">// put dummy sensor information.</span></a>
<a class="sourceLine" id="cb17-15" title="15">        );</a>
<a class="sourceLine" id="cb17-16" title="16">        </a>
<a class="sourceLine" id="cb17-17" title="17">        <span class="co">// do transmit </span></a>
<a class="sourceLine" id="cb17-18" title="18">        <span class="co">//return nwksmpl.transmit(pkt);</span></a>
<a class="sourceLine" id="cb17-19" title="19">        <span class="cf">return</span> pkt.transmit(); </a>
<a class="sourceLine" id="cb17-20" title="20">    }</a>
<a class="sourceLine" id="cb17-21" title="21"></a>
<a class="sourceLine" id="cb17-22" title="22">    <span class="cf">return</span> MWX_APIRET(<span class="kw">false</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb17-23" title="23">}</a></code></pre></div>
<p>This function requests to send a wireless packet to the parent device with ID=<code>0x00</code>. The data to be stored is a four-character identifier (<code>FOURCC</code>) commonly used in the Act sample, plus the system time [ms] and a dummy sensor value (<code>sensor.dummy_work_ct_now</code>).</p>
<p>The first step is to get an object that contains the transmitted packets. This object can then be manipulated to set the data and conditions for transmission.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="cf">if</span> (<span class="kw">auto</span>&amp;&amp; pkt = the_twelite.network.use&lt;NWK_SIMPLE&gt;().prepare_tx_packet()) {</a></code></pre></div>
<p>In the mwx library, the <code>if</code> statement is used to get an object and the <code>bool</code> decision of the object is <code>true</code>. Here, a board object is retrieved by <code>the_twelite.network.use&lt;NWK_SIMPLE&gt;()</code>, and a packet object is retrieved by <code>.prepare_tx_packet()</code> of the board object. Failure to retrieve the packet object is not normally expected, but when it does occur, it is when the transmit queue is full and the transmit request cannot be accepted. Since this example is for a single transmission only, the error is limited to an unexpected serious problem.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1">pkt &lt;&lt; tx_addr(<span class="bn">0x00</span>) <span class="co">// Destination</span></a>
<a class="sourceLine" id="cb19-2" title="2">        &lt;&lt; tx_retry(<span class="bn">0x1</span>) <span class="co">// Number of resends</span></a>
<a class="sourceLine" id="cb19-3" title="3">        &lt;&lt; tx_packet_delay(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>); <span class="co">// Transmission delay</span></a></code></pre></div>
<p>For the resulting <code>pkt</code> object, set the conditions for transmission (destination, retransmission, etc.) using the <code>&lt;&lt;</code> operator. <a href="../api-reference/classes/packet_tx.html#%22tx_addr"><code>tx_addr</code></a> specifies the destination of the packet. The <code>tx_addr</code> specifies the destination of the packet, the <a href="../api-reference/classes/packet_tx.html#%22tx_retry"><code>tx_retry</code></a> specifies the number of retransmissions, and the <a href="../api-reference/classes/packet_tx.html#%22tx_packet_delay"><code>tx_packet_delay</code></a> specifies the transmission delay.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1">pack_bytes(pkt.get_payload() <span class="co">// set payload data objects.</span></a>
<a class="sourceLine" id="cb20-2" title="2">    , make_pair(FOURCC, <span class="dv">4</span>) <span class="co">// string should be paired with length explicitly.</span></a>
<a class="sourceLine" id="cb20-3" title="3">    , <span class="dt">uint32_t</span>(millis()) <span class="co">// put timestamp here.</span></a>
<a class="sourceLine" id="cb20-4" title="4">    , <span class="dt">uint16_t</span>(sensor.dummy_work_ct_now) <span class="co">// put dummy sensor information.</span></a>
<a class="sourceLine" id="cb20-5" title="5">);  </a></code></pre></div>
<p>The payload of a packet is an array of <a href="../api-reference/classes/smplbuf/README.html"><code>smblbuf&lt;uint8_t&gt;</code></a> derivatives obtained by <code>pkt.get_payload()</code>. You can set the value of this array directly, but here we use <a href="../api-reference/funcs/utility/pack_bytes.html"><code>pack_bytes()</code></a> to set the value.</p>
<div class="info">
<p>The maximum length of the payload is 91 bytes in the above example, see<a href="../networks/nwk_simple.html#%22pakettoto">NWK_SIMPLE packet structure and maximum length</a> for more information.</p>
</div>
<p>This function can be specified by a variable number of arguments. The first parameter is an array object obtained from <code>.get_payload()</code>.</p>
<ul>
<li><code>make_pair(FOURCC,4)</code> : <em>make_pair</em> is from the C++ standard library and creates a <em>std::pair object</em>. It means to write out 4 bytes from the beginning for string type.(This is done to explicitly specify the number of bytes to be written, as the topic of including or excluding the end of an array of string types is confusing)</li>
<li>If <code>uint32_t</code> type data is specified, 4 bytes of data are written in big-endian order.</li>
<li>The same applies to data of type <code>uint16_t</code>.</li>
</ul>
<div class="info">
<p>It is also possible to write data using a pointer of type <code>uint8_t</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">auto</span>&amp;&amp; pay = pkt.get_payload(); <span class="co">// get buffer object.</span></a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="co">// the following code will write data directly to internal buffer of `pay&#39; object.</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="dt">uint8_t</span> *p = pay.begin(); <span class="co">// get the pointer of buffer head.</span></a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6">S_OCTET(p, FOURCC[<span class="dv">0</span>]); <span class="co">// store byte at pointer `p&#39; and increment the pointer.</span></a>
<a class="sourceLine" id="cb21-7" title="7">S_OCTET(p, FOURCC[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb21-8" title="8">S_OCTET(p, FOURCC[<span class="dv">2</span>]);</a>
<a class="sourceLine" id="cb21-9" title="9">S_OCTET(p, FOURCC[<span class="dv">3</span>]);</a>
<a class="sourceLine" id="cb21-10" title="10"></a>
<a class="sourceLine" id="cb21-11" title="11">S_DWORD(p, millis()); <span class="co">// store uint32_t data.</span></a>
<a class="sourceLine" id="cb21-12" title="12">S_WORD(p, sensor.dummy_work_ct_now); <span class="co">// store uint16_t data.</span></a>
<a class="sourceLine" id="cb21-13" title="13"></a>
<a class="sourceLine" id="cb21-14" title="14">pay.redim(p - pay.begin());</a></code></pre></div>
<p>The array object obtained from <code>.get_payload()</code> is an array of size 0 with no data stored in it, but it is expanded by writing data to it (actually, writing data to an internal fixed-length buffer and updating the data size in internal management). The final size is the data size of the payload.</p>
<p>Here we use <code>.begin()</code> to get a pointer to <code>uint8_t*</code>, write data using this pointer, and set the last written size with <code>.redim()</code>.</p>
<p>functions (macros) such as <code>S_OCTET()</code>, <code>S_WORD()</code>, and <code>S_DWORD()</code> are used to write data, for example, <code>S_OCTET(p, &#39;H&#39;)</code> is the same as <code>*p = &#39;H&#39;; p++;</code>.</p>
<p>The last <code>.redim()</code> is a procedure to change the size of an array <strong>without initializing the buffer</strong>. Calling <code>.resize()</code> clears everything to zero.</p>
</div>
<p>Finally, <code>.transmit()</code> is called to request sending. The return value is of the type <code>MWX_APIRET</code>. After the request, the actual transmission takes place, which may take several to several tens of milliseconds to complete, depending on the transmission parameters and the size of the transmission. On completion, <code>on_tx_comp()</code> is called.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="cf">return</span> pkt.transmit(); </a></code></pre></div>
<div class="info">
<p>`<code>[</code>MWX_APIRET<code>](../api-reference/classes/mwx\_apiret.html) is a wrapped class of</code>uint32_t<code>type, which uses MSB as a failure success flag and 31 bits as data. It is a return type of</code>pkt.transmit()<code>, and success or failure of the request (cast to</code>bool<code>type) and the ID are stored in the data part (</code>.get_value()`).</p>
</div>
<h3 id="on_tx_comp">on_tx_comp()</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">void</span> on_tx_comp(mwx::packet_ev_tx&amp; ev, <span class="dt">bool_t</span> &amp;b_handled) {</a>
<a class="sourceLine" id="cb23-2" title="2">    step.set_flag(ev.bStatus);</a>
<a class="sourceLine" id="cb23-3" title="3">}</a></code></pre></div>
<p>This is a system event that is called when the transmission is complete. Here, it is set to complete by <code>.set_flag()</code>.</p>
</body>
</html>
