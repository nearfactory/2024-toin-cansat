<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#analogue">Analogue</a><ul>
<li><a href="#constant.">Constant.</a><ul>
<li><a href="#pin-definition.">Pin Definition.</a></li>
</ul></li>
<li><a href="#method.">method.</a><ul>
<li><a href="#setup">setup()</a></li>
<li><a href="#begin">begin()</a></li>
<li><a href="#end">end()</a></li>
<li><a href="#available">available()</a></li>
<li><a href="#read-read_raw">read(), read_raw()</a></li>
</ul></li>
<li><a href="#adc-interrupt-handler.">ADC interrupt handler.</a></li>
<li><a href="#sleep-behavior">Sleep behavior</a></li>
</ul></li>
</ul>
</nav>
<h1 id="analogue">Analogue</h1>
<p>Analogue performs ADC and acquires values. It can continuously acquire multiple channels at a time, and can do so sequentially according to a timer or other cycle.</p>
<h2 id="constant.">Constant.</h2>
<h3 id="pin-definition.">Pin Definition.</h3>
<table>
<thead>
<tr class="header">
<th>constant</th>
<th>classification</th>
<th style="text-align: center;">Pin name in standard apps</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>uint8_t PIN_ANALOGUE::A1 = 0</code></td>
<td>ADC1 pin</td>
<td style="text-align: center;">AI1</td>
</tr>
<tr class="even">
<td><code>uint8_t PIN_ANALOGUE::A2 = 1</code></td>
<td>ADC2 pin</td>
<td style="text-align: center;">AI3</td>
</tr>
</tbody>
</table>
|
<p>
<code>uint8_t PIN_ANALOGUE::A3 = 2</code>
</p>
<p>
<code>uint8_t PIN_ANALOGUE::D0 = 2</code>
</p>
| ADC3 pin (DIO0) *1 | AI2 | |
<p>
<code>uint8_t PIN_ANALOGUE::A4 = 3</code>
</p>
<p>
<code>uint8_t PIN_ANALOGUE::D1 = 3</code>
</p>
<p>| ADC4 pin (DIO1) *1 | AI4 | | <code>uint8_t PIN_ANALOGUE::VCC = 4</code> | Vcc Supply voltage | |</p>
<div class="warning">
<p>In the standard application (App_Twelite), the pin names ADC2/ADC3 in the semiconductor data sheet are AI3/AI2 to match the TWELITE DIP. Please note this.</p>
</div>
<div class="danger">
<p>*1 ADC2/ADC3 pins for both digital and analog are subject to usage procedures and restrictions.</p>
<p>Assume no pull-up on the pin to be used before the ADC starts. If this is not done, the pull-up voltage will always be observed in the ADC.</p>
<pre><code>pinMode(PIN_DIGITAL::DIO0, PIN_MODE::INPUT); 
pinMode(PIN_DIGITAL::DIO1, PIN_MODE::INPUT);</code></pre>
<hr />
<p><strong>In a normal circuit configuration, current leakage occurs during sleep.</strong> It cannot be circumvented by software description alone.</p>
<p>To avoid current leakage during sleep, the GND of the analog circuit section should be disconnected with a FET switch or the like and left floating during sleep. Also, before sleep, set the pin to input and pull-up state.</p>
</div>
<h2 id="method.">method.</h2>
<h3 id="setup">setup()</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> setup(</a>
<a class="sourceLine" id="cb2-2" title="2">        <span class="dt">bool</span> bWaitInit = <span class="kw">false</span>,</a>
<a class="sourceLine" id="cb2-3" title="3">        <span class="dt">uint8_t</span> kick_ev = E_AHI_DEVICE_TICK_TIMER,</a>
<a class="sourceLine" id="cb2-4" title="4">        <span class="dt">void</span> (*fp_on_finish)() = <span class="kw">nullptr</span>) </a></code></pre></div>
<p>Initializes ADCs. setup() starts the regulator inside the semiconductor, specifies the timer device for periodic execution, and specifies the callback function to be called when all ADCs on the specified channel have completed.</p>
<table>
<colgroup>
<col style="width: 4%"></col>
<col style="width: 95%"></col>
</colgroup>
<thead>
<tr class="header">
<th>parameter</th>
<th>explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bWaitInit</code></td>
<td>If true is specified, waits for initialization of the regulator inside the semiconductor.</td>
</tr>
</tbody>
</table>
| <code>kick_ev</code> |
<p>
Specify the timer device to be specified for cyclic execution. The following five types of devices can be specified, and AD is started in the interrupt handler except for the first time.
</p>
<p>
<code>E_AHI_DEVICE_TICK_TIMER (TickTimer)</code>
</p>
<p>
<code>E_AHI_DEVICE_TIMER0 .. 4 (Timer0 .. 4)</code>
</p>
<p>| | <code>fp_on_finish</code> | This callback function is called from within the interrupt handler after all ADCs on the specified ports have finished, and is used when ADC measurement values are to be stored separately in a FIFO queue, etc. |</p>
<h3 id="begin">begin()</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> begin(<span class="dt">uint8_t</span> bmPorts, <span class="dt">uint8_t</span> capt_tick = <span class="dv">1</span>)</a></code></pre></div>
<p>The first parameter specifies the port where the ADC is to be made. The port specification is a bitmap with the bits set corresponding to the port numbers mentioned in the pin definition.For example, if you want to get the values of two pins <code>PIN_ANALOGUE::A2</code> and <code>PIN_ANALOGUE::VCC</code>, specify <code>(1 &lt;&lt;PIN_ANALOGUE::A1 | 1&lt;&lt;PIN_ANALOGUE::VCC )</code>. You can also use <a href="../funcs/utility/pack_bits.html"><code>pack_bits</code></a> and write <code>pack_bits(PIN_ANALOGUE::A1,PIN_ANALOGUE::VCC)</code>.</p>
<p>After calling <code>begin()</code>, the first ADC processing starts immediately, and the processing of the next pin starts from its end interrupt. When all processing is finished (if specified), the callback function is called. It waits until the next timer interrupt occurs before starting a new ADC process.</p>
<p>The second parameter specifies the number of timer interrupts before AC starts. For example, <code>TickTimer</code> is called every 1 ms, but if you specify 16 for the parameter, it will be processed every 16 ms.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> begin()</a></code></pre></div>
<p>Starts ADC processing with default ADC pins (<code>PIN_ANALOGUE::A1</code>, <code>PIN_ANALOGUE::A2</code>). <code>end()</code> resumes the interrupted ADC processing.</p>
<h3 id="end">end()</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> end()</a></code></pre></div>
<p>ADC processing is terminated and the regulator inside the semiconductor is stopped.</p>
<h3 id="available">available()</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">inline</span> <span class="dt">bool</span> available()</a></code></pre></div>
<p>The value of the ADC is set to <code>true</code> after the acquisition. After confirmation by this function, it is <code>false</code> until the next ADC completion.</p>
<h3 id="read-read_raw">read(), read_raw()</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">inline</span> <span class="dt">int16_t</span> read(<span class="dt">uint8_t</span> s)</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">inline</span> <span class="dt">int16_t</span> read_raw(<span class="dt">uint8_t</span> s)</a></code></pre></div>
<p>Reads ADC values. The parameter specifies the ADC pin to be read. <code>read()</code> returns the read value converted to mV and read_raw() returns the ADC value (0..1023).</p>
<div class="info">
<p>It is recommended to read Vcc with <code>read()</code>. This is because a special conversion formula must be applied to convert from <code>read_raw()</code> values to mV.</p>
</div>
<div class="warning">
<p>After ADC completion (available), if the value is read after a delay until near the timing when the next ADC process is executed, the next ADC value may be returned, because the ADC process is executed by an interrupt handler and the value is updated even during the <code>loop()</code> process.</p>
</div>
<h2 id="adc-interrupt-handler.">ADC interrupt handler.</h2>
<p>The ADC interrupt handler is set to <code>periph_analogue::ADC_handler()</code> when <code>setup()</code> is called.</p>
<p>If a different handler is specified by the semiconductor peripheral library, it will not work properly.</p>
<h2 id="sleep-behavior">Sleep behavior</h2>
<p>If the ADC is in cyclic execution state by <code>begin()</code>, ADC processing is resumed after returning from sleep.</p>
</body>
</html>
