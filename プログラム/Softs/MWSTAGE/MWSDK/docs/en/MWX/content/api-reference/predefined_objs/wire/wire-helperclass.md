---
title: Wire (using helper class)
author: "Mono Wireless Inc."
description: accessing Wire (using helper class)
---
# Wire (using helper class)

The helper class version is a more abstract implementation. Creating objects `reader, writer` for reading and writing is the start of using the bus, and destroying the objects is the end of using the bus.

By creating the object in the decision expression of the if statement, the validity period of the object is limited to the scope of the if clause, and the object is destroyed when it exits the if clause, at which point the bus usage termination procedure is performed.

```cpp
if (auto&& wrt = Wire.get_writer(...)) { // Object creation and device communication determination
   // Within this scope (wave brackets) is the validity period of wrt.
   wrt << 0x00; // Writes 0x00 with mwx::stream interface
} 
// wrt is discarded at the point where the if clause is exited, and the use of the bus is terminated
```

Also, read/write objects implement the `mwx::stream` interface, so you can use the `<<` operator, etc.

* Aligning the start and end of bus usage with the validity period of objects improves the visibility of source code and prevents omissions of termination procedures.
* Unification of read/write procedures by `mwx::stream` interface

## loading

Loading process and its termination procedure in scope `if() { ... }` in scope.

```cpp
const uint8_t DEV_ADDR = 0x70;
uint8_t au8data[6];
if (auto&& rdr = Wire.get_reader(DEV_ADDR, 6)) {
		for (auto&& c: au8data) {
			c = rdr();
		}
}

// same above
uint16_t u16temp, u16humd;
uint8_t u8temp_csum, u8humd_csum;
if (auto&& rdr = Wire.get_reader(SHTC3_ADDRESS, 6)) {
		rdr >> u16temp;
		rdr >> u8temp_csum;
		rdr >> u16humd;
		rdr >> u8humd_csum;
}
```

The above reads one byte at a time using the `rdr` object generated by the `get_readr()` method. The parameter of the method is the two-line serial ID to be read. 1.

1. in `if(...) Create a `rdr` object in `. (The type is resolved with the universal reference `auto&&` by type inference. 2.)
The generated `rdr` object defines an `operator bool ()`, which is used to evaluate the decision expression. If communication is possible with the specified ID, `true` is returned. 3.
The `rdr` object defines an `int operator () (void)` operator, which is called to read one byte of data from the 2-wire serial bus. If the read fails, `-1` is returned, and if it succeeds, the read byte value is returned. 4.
4. `if() { ... }` The destructor of `rdr` is called at the end of the scope to `STOP` the two-wire serial bus.



### get\_reader(addr, read\_count=0)

```cpp
periphe_wire::reader
get_reader(uint8_t addr, uint8_t read_count = 0)
```

I2C 読み出しに用いるワーカーオブジェクトを取得します。

| Parameters | Description                                                                                    |
| ------------ | ------------------------------------------------------------------------------------- |
| `addr`       | I2C address for reading                                                                         |
| `read_count` | Number of bytes to read (specifying this value will issue a STOP bit on the last transfer); specifying 0 will result in no STOP bit (some devices may work) |



## write (writer)

Reading with a helper class to perform the writing process and its termination procedure in scope `if() { ... }` in scope.

```cpp
const uint8_t DEV_ADDR = 0x70;
if (auto&& wrt = Wire.get_writer(DEV_ADDR)) {
	wrt(SHTC3_TRIG_H);
	wrt(SHTC3_TRIG_L);
}

// same above
if (auto&& wrt = Wire.get_writer(DEV_ADDR)) {
	wrt << SHTC3_TRIG_H; // int type is handled as uint8_t
	wrt << SHTC3_TRIG_L;
}

```

In the above, the `wrt` object generated by the `get_writer()` method is used to write one byte at a time. The method parameter is the two-line serial ID to be read.

1. `if(...) Generate a `wrt` object in `. (The type name is resolved with `auto' because it is long. 2.)
The generated `wrt` object defines an `operator bool ()`, which is used to evaluate the decision expression. If communication is possible with the specified ID, `true` is returned. 3.
The `wrt` object defines an `int operator () (void)` operator, which is called to write one byte of data to the 2-wire serial bus. If it fails, `-1` is returned, and if it succeeds, the written byte value is returned. 4.
4. `if() { ... }` The destructor of `wrt` is called at the end of the ``scope`` to `STOP` the two-wire serial bus.

### get\_writer()

```cpp
periph_wire::writer
get_writer(uint8_t addr)
```

Obtains the worker object used for I2C export.

| Parameters | Description |
| ------ | ------------- |
| `addr` | I2C address for writing out |



## Worker object (writer)

### << operator

```cpp
operator << (int c)
operator << (uint8_t c)
operator << (uint16_t c) 
operator << (uint32_t c)
```

The `int` and `uint8_t` types transfer 8 bits.



### () operator

```cpp
operator() (uint8_t val)
operator() (int val)
```

Write out 1 byte.



## worker object (reader)

### >> operator

```cpp
operator >> (uint8_t& c)
operator >> (uint16_t& c)
operator >> (uint32_t& c)
operator >> (uint8_t(&c)[N]) // Fixed array of N bytes
```

Reads only the size of each data type.



### () operator

```cpp
int operator() (bool b_stop = false)

//Example
uint8_t dat[6];
if (auto&& rdr = Wire.get_reader(0x70)) {
  for(uint8_t& x : dat) {
    x = rdr();
  }
}
```

Reads 1 byte. Returns -1 if there is an error, returns the byte value read if normal.

If `b_stop` is set to `true`, the STOP bit is issued on that read.



## Example

The following example shows a measurement example of the temperature/humidity sensor SHTC3 of the environmental sensor PAL.

```cpp
Wire.begin();
// reset (may not necessary...)
if (auto&& wrt = Wire.get_writer(0x70)) {
	wrt << 0x80; // SHTC3_SOFT_RST_H
	wrt << 0x05; // SHTC3_SOFT_RST_L
}

delay(5); // wait some

// start read
if (auto&& wrt = Wire.get_writer(0x70)) {
	wrt << 0x60; // SHTC3_TRIG_H
	wrt << 0x9C; // SHTC3_TRIG_L
}

delay(10); // wait some

// read result
uint16_t u16temp, u16humd;
uint8_t u8temp_csum, u8humd_csum;
if (auto&& rdr = Wire.get_reader(0x70, 6)) {
	rdr >> u16temp;
	rdr >> u8temp_csum;
	rdr >> u16humd;
	rdr >> u8humd_csum;
}

// checksum 0x31, init=0xFF
if (CRC8_u8CalcU16(u16temp, 0xff) != u8temp_csum) {
	Serial << format("{SHTC3 T CKSUM %x}", u8temp_csum); }
if (CRC8_u8CalcU16(u16humd, 0xff) != u8humd_csum) {
	Serial << format("{SHTC3 H CKSUM %x}", u8humd_csum); }

// calc temp/humid (degC x 100, % x 100)
int16_t i16Temp = (int16_t)(-4500 + ((17500 * int32_t(u16temp)) >> 16));
int16_t i16Humd = (int16_t)((int32_t(u16humd) * 10000) >> 16);

Serial << "temp=" << int(i16Temp) 
	   << ",humid=" << int(i16Humd) << mwx::crlf;
```
