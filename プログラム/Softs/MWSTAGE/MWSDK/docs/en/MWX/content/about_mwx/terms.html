<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mono Wireless Inc." />
  <title>Terms</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Terms</h1>
<p class="author">Mono Wireless Inc.</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#terms">Terms</a><ul>
<li><a href="#general-terms">General terms</a><ul>
<li><a href="#sdk-twelite-sdk-mwsdk">SDK (TWELITE SDK, MWSDK)</a></li>
<li><a href="#ieee802.15.4">IEEE802.15.4</a></li>
<li><a href="#packet">packet</a></li>
<li><a href="#payload-of-a-packet">payload (of a packet)</a></li>
<li><a href="#node">node</a></li>
</ul></li>
<li><a href="#mwx-library-specific-terms">MWX library specific terms</a><ul>
<li><a href="#act">ACT</a></li>
<li><a href="#behavior"><span>BEHAVIOR</span></a></li>
<li><a href="#class-objects">Class objects</a></li>
</ul></li>
<li><a href="#c-terms">C++ terms</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#c11">C++11</a></li>
<li><a href="#class">Class</a></li>
<li><a href="#wrapper-class">Wrapper class</a></li>
<li><a href="#method-member-function">Method, Member function</a></li>
<li><a href="#object-instance">Object (instance)</a></li>
<li><a href="#constructor">Constructor</a></li>
<li><a href="#destructor">Destructor</a></li>
<li><a href="#abstract-class">abstract class</a></li>
<li><a href="#scope">Scope</a></li>
<li><a href="#namespace">Namespace</a></li>
<li><a href="#template">Template</a></li>
<li><a href="#nullptr">nullptr</a></li>
<li><a href="#reference-type">reference type</a></li>
<li><a href="#type-inference">type inference</a></li>
<li><a href="#container">container</a></li>
<li><a href="#iterator-.begin-.end">Iterator, .begin(), .end()</a></li>
<li><a href="#c-standard-library">C++ standard library</a></li>
<li><a href="#algorithm">Algorithm</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="terms">Terms</h1>
<p>The following is a supplement to the terminology used in this document.</p>
<div class="warning">
<p>The explanation of terms may not be in accordance with the definitions provided in standards and other documents.</p>
</div>
<h2 id="general-terms">General terms</h2>
<h3 id="sdk-twelite-sdk-mwsdk">SDK (TWELITE SDK, MWSDK)</h3>
<p>Software Development Environment</p>
<div class="info">
<p>The SDK for software development of TWELITE wireless microcontrollers is called TWELITE SDK (or MWSDK).</p>
</div>
<h3 id="ieee802.15.4">IEEE802.15.4</h3>
<p>This is the radio standard used by the TWELITE radio module; as long as you use the MWX library, you do not need to be aware of the details of the radio standard.</p>
<h3 id="packet">packet</h3>
<p>The smallest unit of communication in wireless communications.</p>
<p>The maximum amount varies depending on the communication method and settings during communication, but in the MWX library standard communication &lt;NWK_SIMPLE&gt;, the amount of data a user can send in one packet is 90 bytes.</p>
<h3 id="payload-of-a-packet">payload (of a packet)</h3>
<p>It refers to the body of data contained in a wireless packet.</p>
<h3 id="node">node</h3>
<p>It refers to a radio station in a wireless network.</p>
<h2 id="mwx-library-specific-terms">MWX library specific terms</h2>
<h3 id="act">ACT</h3>
<p>A program created using this library. This refers to its source code or the program that runs.</p>
<h3 id="behavior"><a href="../api-reference/behavior/README.html">BEHAVIOR</a></h3>
<p>A program in the form of an event, among other ACTs. The source code or the program that runs it.</p>
<p>BEHAVIORs are described by a single class definition, which describes callback functions from TWENET, events, and interrupt processing, all in one place. There are three types of behaviors available in the MWX library:</p>
<ul>
<li>Application BEHAVIOR: A class defined by the user that describes the application in an event-driven manner.</li>
<li>Board BEHAVIOR: A class to simplify the use of the functionality of the board that implements the TWELITE radio module.</li>
<li>Network BEHAVIOR: A class for simplifying procedures in wireless networks.</li>
</ul>
<p>Behavior names are enclosed in &lt; &gt;. For example, the behavior name for a simple relay network is &lt;NWK_SIMPLE&gt;.</p>
<h3 id="class-objects">Class objects</h3>
<p>In the description of this library, objects that are declared globally from the beginning in the library are referred to as class objects: <code>Serial</code>, <code>Wire</code>, etc. These class objects can be used without any procedure or by performing the start procedure.</p>
<p>Class objects that consume relatively large amounts of memory allocate memory along with the initialization parameters during the initialization procedure (.setup() or .begin() method).</p>
<h2 id="c-terms">C++ terms</h2>
<div class="info">
<p>This is a general term, and assumes knowledge of the C language.</p>
</div>
<h3 id="c">C++</h3>
<p>The C++ language.</p>
<div class="info">
<p>The MWX library is written in C++ and C.</p>
</div>
<h3 id="c11">C++11</h3>
<p>One of the versions of the C++ standard, meaning C++ as of 2011, which was standardized by ISO in 2011. It has been greatly enhanced since its predecessor, C++03. Newer versions such as C++14 and C++17 are available.</p>
<div class="info">
<p>The MWX library is implemented using features and syntax added in C++11, and MWSDK compiler support is limited to C++11.</p>
</div>
<h3 id="class">Class</h3>
<p>A collection of procedures that focus on some data in a single place. A structure contains the procedures for handling that structure. It actually develops into a much deeper topic, but please refer to technical books.</p>
<p>In C++, the keywords struct and class are essentially the same thing, and a class is a class regardless of which keyword it is declared with.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">struct</span> myhello {</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">int</span> _i;</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">void</span> say_hello() { printf(<span class="st">&quot;hello </span><span class="sc">%d\n</span><span class="st">&quot;</span>, _i); }</a>
<a class="sourceLine" id="cb1-4" title="4">};</a></code></pre></div>
<p>If the above class definition was also done in C, for example, it would look like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> _c_myhello {</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="dt">int</span> _i;</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="dt">void</span> (*pf_say_hello)(<span class="kw">struct</span> _c_myhello *);</a>
<a class="sourceLine" id="cb2-4" title="4">} c_myhello;</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="dt">void</span> say_hello(c_myhello*p) { p-&gt;pf_say_hello(); }</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="dt">void</span> init_c_my_hello(c_myhello*p) {</a>
<a class="sourceLine" id="cb2-8" title="8">  p-&gt;pf_say_hello = say_hello;</a>
<a class="sourceLine" id="cb2-9" title="9">}</a></code></pre></div>
<h3 id="wrapper-class">Wrapper class</h3>
<p>It is a class that includes existing C libraries and their internal structures, and adds C++ specific functionality to make it easier to use. In some cases, the description “wrapped ~structure” is used in the explanation.</p>
<div class="info">
<p>The MWX library is a combination of wrapper classes from TWENET’s C library and a set of newly implemented classes.</p>
</div>
<h3 id="method-member-function">Method, Member function</h3>
<p>A function that is defined in a class and is associated with the class.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">struct</span> myhello {</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">int</span> _i;</a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="dt">void</span> say_hello() { printf(<span class="st">&quot;hello </span><span class="sc">%d\n</span><span class="st">&quot;</span>, _i); } <span class="co">//Method</span></a>
<a class="sourceLine" id="cb3-4" title="4">};</a></code></pre></div>
<h3 id="object-instance">Object (instance)</h3>
<p>A class is materialized (allocated memory).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> func() {</a>
<a class="sourceLine" id="cb4-2" title="2">    myhello obj_hello; <span class="co">// obj_hello is an object of myhello class</span></a>
<a class="sourceLine" id="cb4-3" title="3">    obj_hello._i = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb4-4" title="4">    obj_hello.say_hello();</a>
<a class="sourceLine" id="cb4-5" title="5">}</a></code></pre></div>
<p>In this explanation, object and instance are treated as having the same meaning.</p>
<h3 id="constructor">Constructor</h3>
<p>Initialization procedure at the time of object creation.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">struct</span> myhello {</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="dt">int</span> _i;</a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="dt">void</span> say_hello() { printf(<span class="st">&quot;hello </span><span class="sc">%d\n</span><span class="st">&quot;</span>, _i); }</a>
<a class="sourceLine" id="cb5-4" title="4">  </a>
<a class="sourceLine" id="cb5-5" title="5">  myhello(<span class="dt">int</span> i = <span class="dv">0</span>) : _i(i) {} <span class="co">// constructor</span></a>
<a class="sourceLine" id="cb5-6" title="6">};</a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="dt">void</span> my_main() {</a>
<a class="sourceLine" id="cb5-9" title="9">  myhello helo(<span class="dv">10</span>); <span class="co">// Here, the constructor is called and set to _i=10</span></a>
<a class="sourceLine" id="cb5-10" title="10">}</a></code></pre></div>
<h3 id="destructor">Destructor</h3>
<p>This is the procedure when the object is destroyed, paired with the constructor.struct myhello {</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">  <span class="dt">int</span> _i;</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">void</span> say_hello() { printf(<span class="st">&quot;hello! </span><span class="sc">%d\n</span><span class="st">&quot;</span>, _i); }</a>
<a class="sourceLine" id="cb6-3" title="3">  </a>
<a class="sourceLine" id="cb6-4" title="4">  myhello(<span class="dt">int</span> i = <span class="dv">0</span>) : _i(i) {} <span class="co">// constructor</span></a>
<a class="sourceLine" id="cb6-5" title="5">  ~myhello() {</a>
<a class="sourceLine" id="cb6-6" title="6">    printf(<span class="st">&quot;good bye! </span><span class="sc">%d\n</span><span class="st">&quot;</span>, _i);</a>
<a class="sourceLine" id="cb6-7" title="7">  } <span class="co">// destructor</span></a>
<a class="sourceLine" id="cb6-8" title="8">};</a></code></pre></div>
<h3 id="abstract-class">abstract class</h3>
<p>In C++, polymorphism is achieved by virtual classes. Specifically, a class that defines a pure virtual function specified by the virtual keyword.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">struct</span> Base {</a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="kw">virtual</span> <span class="dt">void</span> say_hello() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb7-3" title="3">};</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">struct</span> DeriveEng : <span class="kw">public</span> Base {</a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="dt">void</span> say_hello() { printf(<span class="st">&quot;Hello!&quot;</span>); }</a>
<a class="sourceLine" id="cb7-7" title="7">};</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="kw">struct</span> DeriveJpn : <span class="kw">public</span> Base {</a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="dt">void</span> say_hello() { printf(<span class="st">&quot;Kontiwa!&quot;</span>); }</a>
<a class="sourceLine" id="cb7-11" title="11">};</a></code></pre></div>
<div class="warning">
<p>The MWX library does not use virtual functions due to compiler limitations and performance reasons. We use a <a href="design_policy.html#%22crtpnishitatenpurtopatn">differnet approach</a> to achieve polymorphism.</p>
</div>
<h3 id="scope">Scope</h3>
<p>In the C/C++ language, think of it as a scope enclosed in { }. The objects created in this scope are destroyed when they leave the scope. The destructor is called at this time.</p>
<p>The following is an explicitly scoped version of helo2, which is discarded after line 8 and the destructor is called.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">void</span> my_main() {</a>
<a class="sourceLine" id="cb8-2" title="2">  myhello helo1(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb8-3" title="3">  helo1.say_hello();</a>
<a class="sourceLine" id="cb8-4" title="4">  </a>
<a class="sourceLine" id="cb8-5" title="5">  {</a>
<a class="sourceLine" id="cb8-6" title="6">    myhello helo2(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb8-7" title="7">    helo2.say_hello();</a>
<a class="sourceLine" id="cb8-8" title="8">  }</a>
<a class="sourceLine" id="cb8-9" title="9">}</a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="co">// hello! 1</span></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="co">// hello! 2</span></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="co">// good bye! 2</span></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="co">// good bye! 1</span></a></code></pre></div>
<p>MThe MWX library uses the following notation. Here, the validity period of an object declared within the conditional expression of an if statement (older C languages such as C89 do not allow declarations in such a place) is within {} of the if statement.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">struct</span> myhello {</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="dt">int</span> _i;</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="dt">void</span> say_hello() { printf(<span class="st">&quot;hello! </span><span class="sc">%d\n</span><span class="st">&quot;</span>, _i); }</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="kw">operator</span> <span class="dt">bool</span>() { <span class="cf">return</span> <span class="kw">true</span>; } <span class="co">// Operators for judgment in if()</span></a>
<a class="sourceLine" id="cb9-5" title="5">  </a>
<a class="sourceLine" id="cb9-6" title="6">  myhello(<span class="dt">int</span> i = <span class="dv">0</span>) : _i(i) {} <span class="co">// constructor</span></a>
<a class="sourceLine" id="cb9-7" title="7">  ~myhello() { printf(<span class="st">&quot;good bye! </span><span class="sc">%d\n</span><span class="st">&quot;</span>, _i); } <span class="co">// constructor</span></a>
<a class="sourceLine" id="cb9-8" title="8">};</a>
<a class="sourceLine" id="cb9-9" title="9"></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="co">// Function to create a myhello object (generator)</span></a>
<a class="sourceLine" id="cb9-11" title="11">myhello gen_greeting() { <span class="cf">return</span> my_hello(); }</a>
<a class="sourceLine" id="cb9-12" title="12"></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="dt">void</span> my_main() {</a>
<a class="sourceLine" id="cb9-14" title="14">  <span class="cf">if</span> (myhello x = gen_greeting()) {</a>
<a class="sourceLine" id="cb9-15" title="15">    <span class="co">// The object x in myhello is valid during the if statement</span></a>
<a class="sourceLine" id="cb9-16" title="16">    x.say_hello();</a>
<a class="sourceLine" id="cb9-17" title="17">  }</a>
<a class="sourceLine" id="cb9-18" title="18">  <span class="co">// object x is destroyed when exiting the if minute</span></a>
<a class="sourceLine" id="cb9-19" title="19">}</a></code></pre></div>
<p>For example, a two-wire serial bus is a procedure where there is a start and end procedure and the bus is manipulated by an object only during that time. After the object is created, if the bus is properly connected, the true clause of the if statement is executed and the bus is written or read by the created object. When the bus read/write operation is completed, the if statement is exited and the destructor is called to terminate the bus usage.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="at">const</span> <span class="dt">uint8_t</span> DEV_ADDR = <span class="bn">0x70</span>;</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="cf">if</span> (<span class="kw">auto</span>&amp;&amp; wrt = Wire.get_writer(DEV_ADDR)) { <span class="co">//バスの初期化、接続判定</span></a>
<a class="sourceLine" id="cb10-3" title="3">    wrt(SHTC3_TRIG_H); <span class="co">// 書き出し</span></a>
<a class="sourceLine" id="cb10-4" title="4">    wrt(SHTC3_TRIG_L);</a>
<a class="sourceLine" id="cb10-5" title="5">} <span class="co">// バスの利用終了手続き</span></a></code></pre></div>
<h3 id="namespace">Namespace</h3>
<p>The namespace are actively used in C++ to avoid duplication of definition names. To access a definition in a namespace, use::.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">namespace</span> MY_NAME { <span class="co">// 名Namespace declaration</span></a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="at">const</span> <span class="dt">uint8_t</span> MYVAL1 = <span class="bn">0x00</span>;</a>
<a class="sourceLine" id="cb11-3" title="3">}</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5">...</a>
<a class="sourceLine" id="cb11-6" title="6"><span class="dt">void</span> my_main() {</a>
<a class="sourceLine" id="cb11-7" title="7">  <span class="dt">uint8_t</span> i = MY_NAME::MYVAL1; <span class="co">// reference of MY_NAME</span></a>
<a class="sourceLine" id="cb11-8" title="8">}</a></code></pre></div>
<h3 id="template">Template</h3>
<p>Think of a template as an extension of a C macro.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">int</span> N&gt;</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">class</span> myary {</a>
<a class="sourceLine" id="cb12-3" title="3">  T _buf[N];</a>
<a class="sourceLine" id="cb12-4" title="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb12-5" title="5">  myary() : _buf{} {}</a>
<a class="sourceLine" id="cb12-6" title="6">  T <span class="kw">operator</span> [] (<span class="dt">int</span> i) { <span class="cf">return</span> _buf[i % N]; }</a>
<a class="sourceLine" id="cb12-7" title="7">};</a>
<a class="sourceLine" id="cb12-8" title="8"></a>
<a class="sourceLine" id="cb12-9" title="9">myary&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a1; <span class="co">// Array of type int with 10 elements</span></a>
<a class="sourceLine" id="cb12-10" title="10">myary&lt;<span class="dt">char</span>, <span class="dv">128</span>&gt; a2; <span class="co">// Array of char type with 128 elements</span></a></code></pre></div>
<p>This example defines a simple array, where T and N are template parameters, where T is the type name and N is a number, and defines an array class of type T with N elements.</p>
<h3 id="nullptr">nullptr</h3>
<p>In C++11, NULL pointers are now written as nullptr.</p>
<h3 id="reference-type">reference type</h3>
<p>In C++, reference types are available. This is similar to access by pointer, but with the restriction that it must refer to an object.</p>
<p>For functions with pass-by-reference parameters like the one below, the value of <code>i</code> can be rewritten in <code>incr()</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">void</span> incr(<span class="dt">int</span>&amp; lhs, <span class="dt">int</span> rhs) { lhs += rhs; }</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="dt">void</span> my_main() {</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="dt">int</span> i = <span class="dv">10</span>; j = <span class="dv">20</span>;</a>
<a class="sourceLine" id="cb13-5" title="5">  incr(i, j);</a>
<a class="sourceLine" id="cb13-6" title="6">}</a></code></pre></div>
<p>In the example of the template explanation, the return type of <code>operator[]</code> is changed to <code>T&amp;</code>. By doing so, it becomes possible to perform assignment operations directly on the data inside the array, such as <code>a[0]=1</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="dt">int</span> N&gt;</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="kw">class</span> myary {</a>
<a class="sourceLine" id="cb14-3" title="3">  T _buf[N];</a>
<a class="sourceLine" id="cb14-4" title="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb14-5" title="5">  myary() : _buf{} {}</a>
<a class="sourceLine" id="cb14-6" title="6">  T&amp; <span class="kw">operator</span> [] (<span class="dt">int</span> i) { <span class="cf">return</span> _buf[i % N]; }</a>
<a class="sourceLine" id="cb14-7" title="7">};</a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9">myary&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a1;</a>
<a class="sourceLine" id="cb14-10" title="10"><span class="dt">void</span> my_main() {</a>
<a class="sourceLine" id="cb14-11" title="11">  a1[<span class="dv">0</span>] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb14-12" title="12">  a1[<span class="dv">1</span>] = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb14-13" title="13">}</a></code></pre></div>
<div class="info">
<p>As a rule, the programming interface of the MWX library does not use pointer types, but reference types.</p>
</div>
<h3 id="type-inference">type inference</h3>
<p>C++11 introduces the auto keyword for type inference. This allows the compiler to infer the type of an object from its initialization description, thus omitting the need to specify the specific type name. This is effective in cases where class names using template are very long.</p>
<p>In most of the explanations, auto&amp;&amp;, which is called universal reference, is used. Universal references can be written here without being aware of passing references.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">auto</span>&amp;&amp; p = <span class="bu">std::</span>make_pair(<span class="st">&quot;HELLO&quot;</span>, <span class="dv">5</span>);</a>
<a class="sourceLine" id="cb15-2" title="2">       <span class="co">// const char* と int のペア std::pair</span></a></code></pre></div>
<h3 id="container">container</h3>
<p>A class for storing multiple objects of a specific data type such as arrays is called a container. An array class such as myary mentioned in the template example is also called a container.</p>
<div class="info">
<p>The MWX library provides an array class smplbuf and a FIFO queue class smplque.</p>
</div>
<h3 id="iterator-.begin-.end">Iterator, .begin(), .end()</h3>
<p>A pointer in C can be thought of as a way to access a contiguous set of memory elements in a continuous manner from the beginning to the end. The simplest implementation of a FIFO queue is a ring buffer, but there is no memory continuity. Even such a data structure can be described in the same way as a pointer using an iterator.</p>
<p>The methods <code>.begin()</code> and <code>.end()</code> are used to get the iterator. The iterator that points to the beginning of the container is obtained with <code>.begin()</code>. The iterator that points to the next to the end is obtained with <code>.end()</code>. The reason for using the next to the end instead of the end is for the clarity of the loop description in the for and while statements, and to handle the case where the number of elements stored in the container is zero.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1">my_queue que; <span class="co">// my_queue is a class of queue</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="kw">auto</span>&amp;&amp; p = que.begin();</a>
<a class="sourceLine" id="cb16-4" title="4"><span class="kw">auto</span>&amp;&amp; e = que.end();</a>
<a class="sourceLine" id="cb16-5" title="5"></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="cf">while</span>(p != e) {</a>
<a class="sourceLine" id="cb16-7" title="7">  some_process(*p);</a>
<a class="sourceLine" id="cb16-8" title="8">  ++p;</a>
<a class="sourceLine" id="cb16-9" title="9">}</a></code></pre></div>
<p>In the above, <code>some_process()</code> is applied to each element of the <code>que</code> using the iterator <code>p</code>. <code>p</code> is incremented by the <code>++</code> operator as an iterator that points to the next element. Even if the container has a data structure that cannot be described by a pointer, it can be processed in the same way as using a pointer.</p>
<p>Since <code>.end()</code> indicates the next to the end, the end decision of the while statement is as simple as <code>(p ! = e)</code>, which is concise. If there is no element in the queue, <code>.begin()</code> returns the same iterator as .end(). If there are no elements in the queue, <code>.begin()</code> will return the same iterator as .end(), which is the next iterator after the iterator for the unstored elements.</p>
<p>For a contiguous container in memory, its iterator will usually be a normal pointer. It is not expected to be a large overhead during its operation.</p>
<h3 id="c-standard-library">C++ standard library</h3>
<p>The C++ standard library includes the STL (Standard Template Library), which is part of the MWX library.</p>
<div class="warning">
<p>Due to the <a href="./#zhi-xian-shi-xiang">limitations</a> of the C/C++ compiler for TWELITE, only a few features are available.</p>
</div>
<h3 id="algorithm">Algorithm</h3>
<p>In C, for example, the process of finding the maximum or minimum value is written separately depending on the type. In C++, you can use templates, iterators, etc. to describe such operations independently of their types. This is called an algorithm.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// Return the iterator with the maximum value with any iterator as a parameter.</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">template</span> &lt;<span class="kw">class</span> Iter&gt;</a>
<a class="sourceLine" id="cb17-3" title="3">Iter find_max(Iter b, Iter e) {</a>
<a class="sourceLine" id="cb17-4" title="4">  Iter m = b; ++b;</a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="cf">while</span>(b != e) {</a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="cf">if</span> (*b &gt; *m) { m = b; }</a>
<a class="sourceLine" id="cb17-7" title="7">    ++b;</a>
<a class="sourceLine" id="cb17-8" title="8">  }</a>
<a class="sourceLine" id="cb17-9" title="9">  <span class="cf">return</span> m;</a>
<a class="sourceLine" id="cb17-10" title="10">}</a></code></pre></div>
<p>For example, the algorithm to find the maximum value as shown above. This algorithm is type-independent. (It is called generic programming.)</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="kw">auto</span>&amp;&amp; minmax = <span class="bu">std::</span>minmax_element( <span class="co">// Algorithm for obtaining the maximum minimum</span></a>
<a class="sourceLine" id="cb18-4" title="4">  que.begin(), que.end());</a>
<a class="sourceLine" id="cb18-5" title="5"></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="kw">auto</span>&amp;&amp; min_val = *minmax.first;</a>
<a class="sourceLine" id="cb18-7" title="7"><span class="kw">auto</span>&amp;&amp; max_val = *minmax.second;</a></code></pre></div>
<p>Here we specify an iterator for que and apply the algorithm <code>std::minmax_elenet</code> to obtain its maximum and minimum. <code>std::minmax_elemet</code> is defined in the C++ standard library. Its return value is <code>std::pair</code>, which combines any two values. The algorithm calculates the maximum and minimum values if the elements indicated by the iterator can be compared with each other using operators such as <code>&lt;</code>,<code>&gt;</code>,<code>==</code>. The return type is also derived from the iterator type.</p>
</body>
</html>
