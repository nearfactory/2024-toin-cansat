<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Mono Wireless Inc." />
  <title>Rcv_Unvsl (Universal Reciever)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body { line-height: 1.3em; }
p { line-height: 1.5em; }
img {
display: block;
margin-left: auto;
margin-right: auto;
width: 66%;
}
h1, h2, h3 {
padding: 1em 1em; border-left: 0.5em solid #000;
background: #f4f4f4;
}
h1.title {
all: initial;
font-size: 1em;
border-left: 3em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.author, h2.author {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.date, h3.date {
all: initial;
font-size: 1em;
border-left: 0.5em solid #000;
border-right: 10em solid #000;
padding: 0em 0.5em 0em 0.5em;
font-weight: bold;
}
p.caption {
text-align: center;
font-weight: bold;
}
table {
width: 85%;
margin: auto;
border-collapse: collapse;
border-spacing: 4px;
}
pre {
width: 85%;
padding: 0.5em 1em;
margin: auto;
border:1px solid #333;
padding: 4px;
}
td, th {
border-collapse: collapse;
border:1px solid #333;
}
div.success {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #408040;
background-color: #e0FFe0;
}
div.warning {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #807060;
background-color: #FFF8E8;
}
div.danger {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #FF0000;
background-color: #FFE0E0;
}
div.info {
width: 90%;
margin: 0.5em 1em;
margin-left: auto;
margin-right: auto;
padding: 0.5em 1em;
border: dashed 2px #404080;
background-color: #e8e8FF;
}
div.pageref {
padding: 0.5em 1em;
margin: 2em 0;
color: #232323;
background: #fff8e8;
border-left: solid 10px #ffc06e;
}
code {

padding: 0.2em 0.2em 0.2em 0.2em; background: #f0f0f0;
border: solid 1px #808080;
border-radius: 0.2em;
}
pre code {
background: #ffffff;
border: none;
}</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Rcv_Unvsl (Universal Reciever)</h1>
<p class="author">Mono Wireless Inc.</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#rcv_unvsl-universal-reciever">Rcv_Unvsl (Universal Reciever)</a><ul>
<li><a href="#main.cpp">main.cpp</a><ul>
<li><a href="#setup">setup()</a></li>
<li><a href="#loop">loop()</a></li>
<li><a href="#on_rx_packet">on_rx_packet()</a></li>
</ul></li>
<li><a href="#pkt_common.hpp">pkt_common.hpp</a></li>
<li><a href="#pkt_.hpp-pkt_.cpp">pkt_???.hpp, pkt_???.cpp</a><ul>
<li><a href="#pkt_pal">pkt_pal</a></li>
</ul></li>
<li><a href="#dup_checker">dup_checker</a><ul>
<li><a href="#template-argument">template argument</a></li>
<li><a href="#container">container</a></li>
<li><a href="#duplicate-check">duplicate check</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="rcv_unvsl-universal-reciever">Rcv_Unvsl (Universal Reciever)</h1>
<p>By running <code>NWK_LAYERED</code> on <code>twe_twelite.network</code> and <code>NWK_SIMPLE</code> on <code>twe_twelite.network2</code> in the MWX library, packets of different types, including packets of layered tree net (TWELITE PAL, ARIA, etc) You can receive and interpret various types of packets.</p>
<p>However, wireless packets must be on the same CHANNEL and have the same Application ID.</p>
<h2 id="main.cpp">main.cpp</h2>
<p><code>setup()</code>, <code>loop()</code>, and the callback function <code>on_rx_packet()</code> for incoming packets.</p>
<h3 id="setup">setup()</h3>
<p>These objects are declared in <code>pkt_handler.cpp</code> and initialized by <code>pnew()</code> in <code>setup()</code>. It mainly interprets the payload (data) of the packet.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1">    mwx::pnew(<span class="va">g_pkt_pal</span>);</a>
<a class="sourceLine" id="cb1-2" title="2">    mwx::pnew(<span class="va">g_pkt_apptwelite</span>);</a>
<a class="sourceLine" id="cb1-3" title="3">    mwx::pnew(<span class="va">g_pkt_actsamples</span>);</a>
<a class="sourceLine" id="cb1-4" title="4">    mwx::pnew(<span class="va">g_pkt_unknown</span>);</a></code></pre></div>
<p>Two network objects are created. Be sure to <code>NWK_LAYERED</code> to <code>the_twelite.network</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1">    <span class="kw">auto</span>&amp;&amp; nwk_ly = the_twelite.network.use&lt;NWK_LAYERED&gt;();</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="kw">auto</span>&amp;&amp; nwk_sm = the_twelite.network2.use&lt;NWK_SIMPLE&gt;();</a></code></pre></div>
<h3 id="loop">loop()</h3>
<p>In this sample, the important part of the <code>loop()</code> process is the <code>.refresh()</code> process, which is performed about every second. Only <code>g_pkt_apptwelite().refresh()</code> does the duplicate checker timeout. Other objects do nothing.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">    <span class="cf">if</span> (TickTimer.available()) {</a>
<a class="sourceLine" id="cb3-2" title="2">        <span class="at">static</span> <span class="dt">unsigned</span> t;</a>
<a class="sourceLine" id="cb3-3" title="3">        <span class="cf">if</span> (!(++t &amp; <span class="bn">0x3FF</span>)) {</a>
<a class="sourceLine" id="cb3-4" title="4">            <span class="va">g_pkt_pal</span>.refresh();</a>
<a class="sourceLine" id="cb3-5" title="5">            <span class="va">g_pkt_apptwelite</span>.refresh();</a>
<a class="sourceLine" id="cb3-6" title="6">            <span class="va">g_pkt_actsamples</span>.refresh();</a>
<a class="sourceLine" id="cb3-7" title="7">            <span class="va">g_pkt_unknown</span>.refresh();</a>
<a class="sourceLine" id="cb3-8" title="8">        }</a>
<a class="sourceLine" id="cb3-9" title="9">    }</a></code></pre></div>
<h3 id="on_rx_packet">on_rx_packet()</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> on_rx_packet(packet_rx&amp; rx, <span class="dt">bool_t</span> &amp;handled) {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">auto</span> type = rx.<span class="dt">get_network_type</span>();</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dt">bool</span> b_handled = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="co">// PAL</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="cf">if</span> (!b_handled</a>
<a class="sourceLine" id="cb4-7" title="7">        &amp;&amp; type == mwx::NETWORK::LAYERED</a>
<a class="sourceLine" id="cb4-8" title="8">        &amp;&amp; <span class="va">g_pkt_pal</span>.analyze(rx, b_handled)</a>
<a class="sourceLine" id="cb4-9" title="9">    ) {</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="va">g_pkt_pal</span>.display(rx);</a>
<a class="sourceLine" id="cb4-11" title="11">    }</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="co">// Act samples</span></a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="cf">if</span> (!b_handled</a>
<a class="sourceLine" id="cb4-15" title="15">        &amp;&amp; type == mwx::NETWORK::SIMPLE</a>
<a class="sourceLine" id="cb4-16" title="16">        &amp;&amp; <span class="va">g_pkt_actsamples</span>.analyze(rx, b_handled)</a>
<a class="sourceLine" id="cb4-17" title="17">    ) {</a>
<a class="sourceLine" id="cb4-18" title="18">        <span class="va">g_pkt_actsamples</span>.display(rx);</a>
<a class="sourceLine" id="cb4-19" title="19">    }</a>
<a class="sourceLine" id="cb4-20" title="20"></a>
<a class="sourceLine" id="cb4-21" title="21">    <span class="co">// Standard application (e.g. App_Twelite)</span></a>
<a class="sourceLine" id="cb4-22" title="22">    <span class="cf">if</span> (!b_handled</a>
<a class="sourceLine" id="cb4-23" title="23">        &amp;&amp; type == mwx::NETWORK::NONE</a>
<a class="sourceLine" id="cb4-24" title="24">        &amp;&amp; <span class="va">g_pkt_apptwelite</span>.analyze(rx, b_handled)</a>
<a class="sourceLine" id="cb4-25" title="25">    ) {</a>
<a class="sourceLine" id="cb4-26" title="26">        <span class="va">g_pkt_apptwelite</span>.display(rx);</a>
<a class="sourceLine" id="cb4-27" title="27">    }</a>
<a class="sourceLine" id="cb4-28" title="28"></a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="co">// unknown</span></a>
<a class="sourceLine" id="cb4-30" title="30">    <span class="cf">if</span> (!b_handled) {</a>
<a class="sourceLine" id="cb4-31" title="31">        <span class="va">g_pkt_unknown</span>.analyze(rx, b_handled);</a>
<a class="sourceLine" id="cb4-32" title="32">        <span class="va">g_pkt_unknown</span>.display(rx);</a>
<a class="sourceLine" id="cb4-33" title="33">    }</a>
<a class="sourceLine" id="cb4-34" title="34">}</a></code></pre></div>
<p>This is the most important part of this sample code. <code>auto type = rx.get_network_type();</code> determines the packet type.</p>
<ul>
<li><code>mwx::NETWORK::LAYERED</code> : <code>NWK_LAYERED</code> layer tree net ket</li>
<li><code>mwx::NETWORK::SIMPLE</code> : <code>NWK_SIMPLE</code> packets</li>
<li><code>mwx::NETWORK::NONE</code> : no network (e.g. App_Twelite)</li>
<li>other : error or unsupported packets</li>
</ul>
<p>In the case of <code>mwx::NETWORK::NONE</code>, the MWX library does not handle duplicate checkers for the same packet that may be sent in multiple retransmissions. It is necessary to describe the handling of these. In this sample, <code>dup_checker.hpp</code> and <code>dup_checker.cpp</code> are provided.</p>
<p>Interpretation of the packet refers to the <code>packet_rx&amp;</code> object that wraps <code>tsRxDataApp*</code>. The <code>packet_rx</code> class itself has no special functionality, it only defines a means of accessing some information obtained from <code>tsRxDataApp*</code> using <code>get_psRxDataApp()</code>.</p>
<h2 id="pkt_common.hpp">pkt_common.hpp</h2>
<p>It is defined for the purpose of unifying the interface of the packet interpretation part.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">template</span> &lt;<span class="kw">class</span> D&gt;</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">struct</span> pkt_handler {</a>
<a class="sourceLine" id="cb5-3" title="3">    D&amp; self() { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;D&amp;&gt;(*<span class="kw">this</span>); }</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="dt">bool</span> analyze(packet_rx&amp; rx, <span class="dt">bool</span> &amp;b_handled) {</a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="cf">return</span> self().pkt.analyze(rx, b_handled);</a>
<a class="sourceLine" id="cb5-6" title="6">    }</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="dt">void</span> display(packet_rx&amp; rx) {</a>
<a class="sourceLine" id="cb5-8" title="8">        Serial</a>
<a class="sourceLine" id="cb5-9" title="9">            &lt;&lt; crlf</a>
<a class="sourceLine" id="cb5-10" title="10">            &lt;&lt; format(<span class="st">&quot;!PKT_</span><span class="sc">%s</span><span class="st">(%03d-%08x/S=</span><span class="sc">%d</span><span class="st">/L=%03d/V=%04d)&quot;</span></a>
<a class="sourceLine" id="cb5-11" title="11">                    , self().<span class="dt">get_label_packet_type</span>()</a>
<a class="sourceLine" id="cb5-12" title="12">                    , self().pkt.data.u<span class="dv">8</span><span class="er">addr_src</span></a>
<a class="sourceLine" id="cb5-13" title="13">                    , self().pkt.data.u<span class="dv">32</span><span class="er">addr_src</span></a>
<a class="sourceLine" id="cb5-14" title="14">                    , rx.get_psRxDataApp()-&gt;u<span class="dv">8</span><span class="er">Seq</span></a>
<a class="sourceLine" id="cb5-15" title="15">                    , rx.get_lqi()</a>
<a class="sourceLine" id="cb5-16" title="16">                    , self().pkt.data.u<span class="dv">16</span><span class="er">volt</span></a>
<a class="sourceLine" id="cb5-17" title="17">                    );</a>
<a class="sourceLine" id="cb5-18" title="18"></a>
<a class="sourceLine" id="cb5-19" title="19">        self().disp_detail(rx);</a>
<a class="sourceLine" id="cb5-20" title="20">    }</a>
<a class="sourceLine" id="cb5-21" title="21">    <span class="dt">void</span> refresh() {</a>
<a class="sourceLine" id="cb5-22" title="22">        self()._refresh();</a>
<a class="sourceLine" id="cb5-23" title="23">    }</a>
<a class="sourceLine" id="cb5-24" title="24">};</a>
<a class="sourceLine" id="cb5-25" title="25"></a>
<a class="sourceLine" id="cb5-26" title="26"><span class="co">// packet analyzer for App_Twelite</span></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="kw">class</span> pkt_handler_apptwelite : <span class="kw">public</span> pkt_handler&lt;pkt_handler_apptwelite&gt; {</a>
<a class="sourceLine" id="cb5-28" title="28">    <span class="kw">friend</span> <span class="kw">class</span> pkt_handler&lt;pkt_handler_apptwelite&gt;;</a>
<a class="sourceLine" id="cb5-29" title="29">    pkt_apptwelite pkt;</a>
<a class="sourceLine" id="cb5-30" title="30">    <span class="dt">void</span> disp_detail(packet_rx&amp; rx);</a>
<a class="sourceLine" id="cb5-31" title="31">    <span class="at">const</span> <span class="dt">char</span>* <span class="dt">get_label_packet_type</span>() { <span class="cf">return</span> <span class="st">&quot;AppTwelite&quot;</span>; }</a>
<a class="sourceLine" id="cb5-32" title="32">    <span class="dt">void</span> _refresh() { pkt.refresh(); }</a>
<a class="sourceLine" id="cb5-33" title="33"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb5-34" title="34">    pkt_handler_apptwelite() : pkt() {}</a>
<a class="sourceLine" id="cb5-35" title="35">};</a></code></pre></div>
<ul>
<li><code>analyze()</code> : interpret the payload of a packet.</li>
<li><code>display()</code> : Display packet information.</li>
<li><code>refresh()</code> : describe the process every second.</li>
<li><code>self()</code> : cast to the derived class <code>D</code>.</li>
</ul>
<p>In addition, the packet interpretation class (example <code>pkt_handler_apptwelite</code> above) contains a member object <code>pkt</code>. The actual packet interpretation part is done in <code>pkt_???.cpp</code>.</p>
<h2 id="pkt_.hpp-pkt_.cpp">pkt_???.hpp, pkt_???.cpp</h2>
<p>A packet interpretation part <code>analyze()</code> for each packet type and a data structure <code>data</code> are defined. The member <code>data</code> is a structure but inherits the common structure of <code>PktDataCommon</code>. This common part is used to concisely describe the code for serial output of the packet’s data.</p>
<h3 id="pkt_pal">pkt_pal</h3>
<p>Corresponds to PAL-related packets; the PAL packet structure has a complex data structure. The implementation here is based on the EASTL container.</p>
<ul>
<li><code>_vect_pal_sensors</code> : pool of <code>_pal_sensor</code> objects. This object is a dedicated class for use with instusive map.</li>
<li><code>_map_pal_sensors</code> : intrusive map structure for efficient retrieval of sensor data.</li>
</ul>
<p>Allocate an entry in <code>_vect_pal_sensors</code> for each of the multiple data in a packet as they are added and store the value. Once all the data in a packet has been interpreted, a <code>_map_pal_sensors</code> is constructed with the sensor type as the key.</p>
<h2 id="dup_checker">dup_checker</h2>
<p>Implement a duplicate checker. The behavior of the checker can be customized by template arguments.</p>
<h3 id="template-argument">template argument</h3>
<ul>
<li><code>MODE</code> : If <code>MODE_REJECT_SAME_SEQ</code> is specified, packets with the same sequence number are excluded. This is used when the packet order is reordering. The <code>MODE_REJECT_OLDER_SEQ</code> adopts a more recent number.</li>
<li><code>TIMEOUT_ms</code> : The interval at which to initialize the duplicate database. If <code>1000</code> is specified, data after 1 second will be erased. Packets that were excluded immediately before will be adopted again when the duplicate database is initialized.</li>
<li><code>N_ENTRIES</code> : The maximum number of elements to be allocated in the data structure.</li>
<li><code>N_BUCKET_HASH</code> : Maximum number of hash values. Specifies a prime number. It is determined based on the type of wireless node being received.</li>
</ul>
<h3 id="container">container</h3>
<ul>
<li><code>_mmap_entries</code> : It is an intrusive hash multi-map structure. The search key is the serial number of the wireless node.</li>
<li><code>_vect_pool</code> : Allocates a fixed number (<code>N_ENTRIES</code>) of elements used in the map structure.</li>
<li><code>_ring_vecant_idx</code> : Keeps track of <code>_vect_pool</code> elements not used in <code>_mmap_entries</code> by array index number. It is a ring buffer structure, which takes one value from the ring buffer when adding elements and returns a value to the ring buffer when removing elements.</li>
</ul>
<h3 id="duplicate-check">duplicate check</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1">    <span class="dt">bool</span> check_dup(<span class="dt">uint32_t</span> u32ser, <span class="dt">uint16_t</span> u16val, <span class="dt">uint32_t</span> u32_timestamp) {</a>
<a class="sourceLine" id="cb6-2" title="2">        <span class="co">// find entry by key:u32ser.</span></a>
<a class="sourceLine" id="cb6-3" title="3">        <span class="kw">auto</span> r = _mmap_entries.equal_range(u32ser);</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5">        ...</a>
<a class="sourceLine" id="cb6-6" title="6">    }</a></code></pre></div>
<p>To retrieve data from the multimap structure, call <code>.equal_range()</code>. The resulting <code>r</code> is an iterator that enumerates elements with the same serial number.</p>
<p>Each element (<code>_dup_checker_entry</code>) has a timestamp and sequence number. Duplicates are checked according to these values.</p>
</body>
</html>
